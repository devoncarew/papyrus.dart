<!DOCTYPE html>

<!-- generated by papyrus.dart -->

<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Library dart.async</title>
	<link href="bootstrap.css" rel="stylesheet" media="screen">
</head>

<body>
<header>
</header>
<div class='container'>
<div class='row'>
<div class='span3'>
	<ul class="nav nav-tabs nav-stacked left-nav">
		<li><a href="chrome.html"><i class="chevron-nav icon-chevron-right"></i> chrome</a></li>
		<li class="active"><a href="dart.async.html"><i class="chevron-nav icon-white icon-chevron-right"></i> dart.async</a></li>
		<li><a href="dart.collection.html"><i class="chevron-nav icon-chevron-right"></i> dart.collection</a></li>
		<li><a href="dart.convert.html"><i class="chevron-nav icon-chevron-right"></i> dart.convert</a></li>
		<li><a href="dart.core.html"><i class="chevron-nav icon-chevron-right"></i> dart.core</a></li>
		<li><a href="dart.dom.html.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.html</a></li>
		<li><a href="dart.dom.indexed_db.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.indexed_db</a></li>
		<li><a href="dart.dom.svg.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.svg</a></li>
		<li><a href="dart.dom.web_audio.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.web_audio</a></li>
		<li><a href="dart.dom.web_gl.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.web_gl</a></li>
		<li><a href="dart.dom.web_sql.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.web_sql</a></li>
		<li><a href="dart.io.html"><i class="chevron-nav icon-chevron-right"></i> dart.io</a></li>
		<li><a href="dart.isolate.html"><i class="chevron-nav icon-chevron-right"></i> dart.isolate</a></li>
		<li><a href="dart.js.html"><i class="chevron-nav icon-chevron-right"></i> dart.js</a></li>
		<li><a href="dart.json.html"><i class="chevron-nav icon-chevron-right"></i> dart.json</a></li>
		<li><a href="dart.math.html"><i class="chevron-nav icon-chevron-right"></i> dart.math</a></li>
		<li><a href="dart.mirrors.html"><i class="chevron-nav icon-chevron-right"></i> dart.mirrors</a></li>
		<li><a href="dart.typed_data.html"><i class="chevron-nav icon-chevron-right"></i> dart.typed_data</a></li>
		<li><a href="dart.utf.html"><i class="chevron-nav icon-chevron-right"></i> dart.utf</a></li>
	</ul>
</div>
<div class='span9'>
	<h1>dart.async</h1>
	<hr>
	<dl class=dl-horizontal>
		<dt>Functions</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#getAttachedStackTrace>getAttachedStackTrace</a>(dynamic o): dynamic<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#runAsync>runAsync</a>( callback): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#runZonedExperimental>runZonedExperimental</a>( body,  onRunAsync,  onError,  onDone): dynamic<br>
		</dd>
		<dt>Classes</dt>
		<dd>
			<i class=icon-leaf></i> <a href=dart.async.html#Completer>Completer</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#DeferredLibrary>DeferredLibrary</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#EventSink>EventSink</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#EventTransformStream>EventTransformStream</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#Stream>Stream</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamConsumer>StreamConsumer</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamController>StreamController</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamEventTransformer>StreamEventTransformer</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamIterator>StreamIterator</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamSink>StreamSink</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamSubscription>StreamSubscription</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamTransformer>StreamTransformer</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamView>StreamView</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#Timer>Timer</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>Support for asynchronous programming, with classes such as Future and Stream. </p>
<p>For an introduction to using dart:async, see the dart:async section of the language tour (https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-asynchronous-programming). Also see articles(https://www.dartlang.org/articles/) such as Using Future Based APIs (https://www.dartlang.org/articles/using-future-based-apis/).</p>
	</div>
	<h4>Functions</h4>
	<div class=indent>
		<b><a id=getAttachedStackTrace></a><i class=icon-ok-sign></i> static dynamic getAttachedStackTrace(dynamic o)</b>
		<div class=indent>
			<p><i>This is an experimental API.</i> </p>
<p>Get the StackTrace attached to o. </p>
<p>If object o was thrown and caught in a dart:async method, a StackTrace object was attached to it. Use getAttachedStackTrace to get that object. </p>
<p>Returns null if no StackTrace was attached.</p>
		</div>
		<b><a id=runAsync></a><i class=icon-ok-sign></i> static void runAsync( callback)</b>
		<div class=indent>
			<p>Runs the given callback asynchronously. </p>
<p>Callbacks registered through this function are always executed in order and are guaranteed to run before other asynchronous events (like Timer events, or DOM events). </p>
<p>Warning: it is possible to starve the DOM by registering asynchronous callbacks through this method. For example the following program will run the callbacks without ever giving the Timer callback a chance to execute: </p>
<p><pre>Timer.run(() { print("executed"); });  // Will never be executed;
foo() {
  asyncRun(foo);  // Schedules [foo] in front of other events.
}
main() {
  foo();
}
</pre></p>
		</div>
		<b><a id=runZonedExperimental></a><i class=icon-ok-sign></i> static dynamic runZonedExperimental( body,  onRunAsync,  onError,  onDone)</b>
		<div class=indent>
			<p>Runs body in its own zone. </p>
<p>If onError is non-null the zone is considered an error zone. All uncaught errors, synchronous or asynchronous, in the zone are caught and handled by the callback. </p>
<p>The onDone handler (if non-null) is invoked when the zone has no more outstanding callbacks. <i>Deprecated</i>: this method is less useful than it seems, because it assumes that every registered callback is always invoked. There are, however, many <i>valid</i> reasons not to complete futures or to abort a future-chain. In general it is a bad idea to rely on <code>onDone</code>. </p>
<p>The onRunAsync handler (if non-null) is invoked when the body executes runAsync.  The handler is invoked in the outer zone and can therefore execute runAsync without recursing. The given callback must be executed eventually. Otherwise the nested zone will not complete. It must be executed only once. </p>
<p>Examples: </p>
<p><pre>runZonedExperimental(() {
  new Future(() { throw "asynchronous error"; });
}, onError: print);  // Will print "asynchronous error".
</pre>The following example prints "1", "2", "3", "4" in this order. </p>
<p><pre>runZonedExperimental(() {
  print(1);
  new Future.value(3).then(print);
}, onDone: () { print(4); });
print(2);
</pre>Errors may never cross error-zone boundaries. This is intuitive for leaving a zone, but it also applies for errors that would enter an error-zone. Errors that try to cross error-zone boundaries are considered uncaught. </p>
<p><pre>var future = new Future.value(499);
runZonedExperimental(() {
  future = future.then((_) { throw "error in first error-zone"; });
  runZonedExperimental(() {
    future = future.catchError((e) { print("Never reached!"); });
  }, onError: (e) { print("unused error handler"); });
}, onError: (e) { print("catches error of first error-zone."); });
</pre>The following example prints the stack trace whenever a callback is registered using runAsync (which is also used by Completers and StreamControllers. </p>
<p><pre>printStackTrace() { try { throw 0; } catch(e, s) { print(s); } }
runZonedExperimental(body, onRunAsync: (callback) {
  printStackTrace();
  runAsync(callback);
});
</pre></p>
		</div>
	</div>
	<a id=Completer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class Completer</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Completer.future>future</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Completer.isCompleted>isCompleted</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#future>future</a>: <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isCompleted>isCompleted</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Completer.>Completer</a>()<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Completer.sync>Completer.sync</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Completer.complete>complete</a>(T value): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Completer.completeError>completeError</a>(<a href=dart.core.html#Object>Object</a> exception, <a href=dart.core.html#Object>Object</a> stackTrace): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A Completer is used to produce Futures and to complete those futures with a value or error at a later time. </p>
<p>A class that wants to return Futures can use a Completer as follows: </p>
<p><pre>Class myAsyncOperation {
  Completer _completer = new Completer();

  Future&lt;T&gt; myOp() {
    _startOperation();
    // send future object back to client...
    return _completer.future;
  }

  // Something calls this when the value is ready.
  _finishOperation(T result) {
    _completer.complete(value);
  }

  // If something goes wrong, call this.
  _errorHappened(error) {
    _completer.completeError(error);
  }
}
</pre></p>
	</div>
	<h4>Fields</h4>
	<b><a id=Completer.future></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> future</b>
	<div class=indent></div>
	<b><a id=Completer.isCompleted></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isCompleted</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=future></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; get future</b>
	<div class=indent>
		<p>The future that will contain the result provided to this completer.</p>
	</div>
	<b><a id=isCompleted></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isCompleted</b>
	<div class=indent>
		<p>Whether the future has been completed.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Completer.></a><i class=icon-plus-sign></i> factory Completer()</b>
	<div class=indent>
		<p>Creates a completer whose future is completed asynchronously, sometime after complete is called on it. This allows a call to complete to be in the middle of other code, without running an unknown amount of future completion and then callbacks synchronously at the point that complete is called. </p>
<p>Example: </p>
<p><pre>var completer = new Completer.sync();
completer.future.then((_) { bar(); });
// The completion is the result of the asynchronous onDone event.
// However, there is code executed after the call to complete,
// but before completer.future runs its completion callback.
stream.listen(print, onDone: () {
  completer.complete("done");
  foo();  // In this case, foo() runs before bar().
});
</pre></p>
	</div>
	<b><a id=Completer.sync></a><i class=icon-plus-sign></i> factory Completer.sync()</b>
	<div class=indent>
		<p>Completes the future synchronously. </p>
<p>This constructor should be avoided unless the completion of the future is known to be the final result of another asynchronous operation. If in doubt use the default Completer constructor. </p>
<p>Example: </p>
<p><pre>var completer = new Completer.sync();
// The completion is the result of the asynchronous onDone event.
// No other operation is performed after the completion. It is safe
// to use the Completer.sync constructor.
stream.listen(print, onDone: () { completer.complete("done"); });
</pre>Bad example. Do not use this code. Only for illustrative purposes: </p>
<p><pre>var completer = new Completer.sync();
completer.future.then((_) { bar(); });
// The completion is the result of the asynchronous onDone event.
// However, there is still code executed after the completion. This
// operation is *not* safe.
stream.listen(print, onDone: () {
  completer.complete("done");
  foo();  // In this case, foo() runs after bar().
});
</pre></p>
	</div>
	<h4>Methods</h4>
	<b><a id=Completer.complete></a><i class=icon-ok-sign></i> void complete(T value)</b>
	<div class=indent>
		<p>Completes future with the supplied values. </p>
<p>All listeners on the future are informed about the value.</p>
	</div>
	<b><a id=Completer.completeError></a><i class=icon-ok-sign></i> void completeError(<a href=dart.core.html#Object>Object</a> exception, <a href=dart.core.html#Object>Object</a> stackTrace)</b>
	<div class=indent>
		<p>Complete future with an error. </p>
<p>Completing a future with an error indicates that an exception was thrown while trying to produce a value. </p>
<p>The argument exception must not be <code>null</code>.</p>
	</div>
	<a id=DeferredLibrary></a><hr>
	<h4>
		<i class=icon-leaf></i> Class DeferredLibrary</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#DeferredLibrary.libraryName>libraryName</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#DeferredLibrary.uri>uri</a>: <a href=dart.core.html#String>String</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#DeferredLibrary.>DeferredLibrary</a>(<a href=dart.core.html#String>String</a> libraryName, <a href=dart.core.html#String>String</a> uri)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#DeferredLibrary.load>load</a>(): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Indicates that loading of <a href=dart.async.html#libraryName>libraryName</a> is deferred. </p>
<p>Applies to library imports, when used as metadata. </p>
<p>Example usage: </p>
<p><pre>@lazy
import 'foo.dart' as foo;

const lazy = const DeferredLibrary('com.example.foo');

void main() {
  foo.method(); // Throws a NoSuchMethodError, foo is not loaded yet.
  lazy.load().then(onFooLoaded);
}

void onFooLoaded(_) {
  foo.method();
}
</pre></p>
	</div>
	<h4>Fields</h4>
	<b><a id=DeferredLibrary.libraryName></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> libraryName</b>
	<div class=indent></div>
	<b><a id=DeferredLibrary.uri></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> uri</b>
	<div class=indent></div>
	<h4>Constructors</h4>
	<b><a id=DeferredLibrary.></a><i class=icon-plus-sign></i> DeferredLibrary(<a href=dart.core.html#String>String</a> libraryName, <a href=dart.core.html#String>String</a> uri)</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=DeferredLibrary.load></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; load()</b>
	<div class=indent>
		<p>Ensure that libraryName has been loaded. </p>
<p>The value of the returned future is true if this invocation of load caused the library to be loaded.</p>
	</div>
	<a id=EventSink></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class EventSink</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#EventSink.>EventSink</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#EventSink.add>add</a>(T event): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#EventSink.addError>addError</a>(dynamic errorEvent): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#EventSink.close>close</a>(): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>An interface that abstracts creation or handling of Stream events.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=EventSink.></a><i class=icon-plus-sign></i> EventSink()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=EventSink.add></a><i class=icon-ok-sign></i> void add(T event)</b>
	<div class=indent>
		<p>Create a data event</p>
	</div>
	<b><a id=EventSink.addError></a><i class=icon-ok-sign></i> void addError(dynamic errorEvent)</b>
	<div class=indent>
		<p>Create an async error.</p>
	</div>
	<b><a id=EventSink.close></a><i class=icon-ok-sign></i> void close()</b>
	<div class=indent>
		<p>Request a stream to close.</p>
	</div>
	<a id=EventTransformStream></a><hr>
	<h4>
		<i class=icon-leaf></i> Class EventTransformStream extends <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#EventTransformStream.>EventTransformStream</a>(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; source, <a href=dart.async.html#StreamEventTransformer>StreamEventTransformer</a>&lt;S, T&gt; transformer)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#EventTransformStream.listen>listen</a>(&lt;S, T&gt; onData, &lt;S, T&gt; onError, &lt;S, T&gt; onDone, <a href=dart.core.html#bool>bool</a> cancelOnError): <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Stream that transforms another stream by intercepting and replacing events. </p>
<p>This Stream is a transformation of a source stream. Listening on this stream is the same as listening on the source stream, except that events are intercepted and modified by a StreamEventTransformer before becoming events on this stream.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=EventTransformStream.></a><i class=icon-plus-sign></i> EventTransformStream(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; source, <a href=dart.async.html#StreamEventTransformer>StreamEventTransformer</a>&lt;S, T&gt; transformer)</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=EventTransformStream.listen></a><i class=icon-ok-sign></i> <a href='dart.async.html#Stream.listen'><i title='Overrides Stream.listen()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt; listen(&lt;S, T&gt; onData, &lt;S, T&gt; onError, &lt;S, T&gt; onDone, <a href=dart.core.html#bool>bool</a> cancelOnError)</b>
	<div class=indent>
		<p>Adds a subscription to this stream. </p>
<p>On each data event from this stream, the subscriber's onData handler is called. If onData is null, nothing happens. </p>
<p>On errors from this stream, the onError handler is given a object describing the error. </p>
<p>If this stream closes, the onDone handler is called. </p>
<p>If cancelOnError is true, the subscription is ended when the first error is reported. The default is false.</p>
	</div>
	<a id=Future></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class Future</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.>Future</a>(&lt;T&gt; computation)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.delayed>Future.delayed</a>(<a href=dart.core.html#Duration>Duration</a> duration, &lt;T&gt; computation)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.error>Future.error</a>(dynamic error, <a href=dart.core.html#Object>Object</a> stackTrace)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.sync>Future.sync</a>(&lt;T&gt; computation)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.value>Future.value</a>(T value)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.asStream>asStream</a>(): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.catchError>catchError</a>(&lt;T&gt; onError, &lt;T&gt; test): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.forEach>forEach</a>(<a href=dart.core.html#Iterable>Iterable</a>&lt;dynamic&gt; input, &lt;T&gt; f): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.then>then</a>(&lt;T&gt; onValue, &lt;T&gt; onError): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.wait>wait</a>(<a href=dart.core.html#Iterable>Iterable</a>&lt;<a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;&gt; futures): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#List>List</a>&lt;dynamic&gt;&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.whenComplete>whenComplete</a>(&lt;T&gt; action): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A Future represents a delayed computation. It is used to obtain a not-yet available value, or error, sometime in the future.  Receivers of a Future can register callbacks that handle the value or error once it is available. For example: </p>
<p><pre>Future&lt;int&gt; future = getFuture();
future.then((value) =&gt; handleValue(value))
      .catchError((error) =&gt; handleError(error));
</pre>A Future can be completed in two ways: with a value ("the future succeeds") or with an error ("the future fails"). Users can install callbacks for each case. The result of registering a pair of callbacks is a new Future (the "successor") which in turn is completed with the result of invoking the corresponding callback. The successor is completed with an error if the invoked callback throws. For example: </p>
<p><pre>Future&lt;int&gt; successor = future.then((int value) {
    // Invoked when the future is completed with a value.
    return 42;  // The successor is completed with the value 42.
  },
  onError: (e) {
    // Invoked when the future is completed with an error.
    if (canHandle(e)) {
      return 499;  // The successor is completed with the value 499.
    } else {
      throw e;  // The successor is completed with the error e.
    }
  });
</pre>If a future does not have a successor but is completed with an error, it forwards the error message to the global error-handler. This special casing makes sure that no error is silently dropped. However, it also means that error handlers should be installed early, so that they are present as soon as a future is completed with an error. The following example demonstrates this potential bug: </p>
<p><pre>var future = getFuture();
new Timer(new Duration(milliseconds: 5), () {
  // The error-handler is only attached 5ms after the future has been
  // received. If the future fails in the mean-time it will forward the
  // error to the global error-handler, even though there is code (just
  // below) to handle the error.
  future.then((value) { useValue(value); },
              onError: (e) { handleError(e); });
});
</pre>In general we discourage registering the two callbacks at the same time, but prefer to use <a href=dart.async.html#Future.then>then()</a> with one argument (the value handler), and to use <a href=dart.async.html#Future.catchError>catchError()</a> for handling errors. The missing callbacks (the error-handler for <a href=dart.async.html#Future.then>then()</a>, and the value-handler for <a href=dart.async.html#Future.catchError>catchError()</a>), are automatically configured to "forward" the value/error. Separating value and error-handling into separate registration calls usually leads to code that is easier to reason about. In fact it makes asynchronous code very similar to synchronous code: </p>
<p><pre>// Synchronous code.
try {
  int value = foo();
  return bar(value);
} catch (e) {
  return 499;
}
</pre>Equivalent asynchronous code, based on futures: </p>
<p><pre>Future&lt;int&gt; future = foo();  // foo now returns a future.
future.then((int value) =&gt; bar(value))
      .catchError((e) =&gt; 499);
</pre>Similar to the synchronous code, the error handler (registered with <a href=dart.async.html#Future.catchError>catchError()</a>) is handling the errors for exceptions coming from calls to 'foo', as well as 'bar'. This would not be the case if the error-handler was registered at the same time as the value-handler. </p>
<p>Futures can have more than one callback-pairs registered. Each successor is treated independently and is handled as if it was the only successor.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Future.></a><i class=icon-plus-sign></i> factory Future(&lt;T&gt; computation)</b>
	<div class=indent>
		<p>Creates a future containing the result of calling computation asynchronously with Timer.run. </p>
<p>if the result of executing computation throws, the returned future is completed with the error. If a thrown value is an AsyncError, it is used directly, instead of wrapping this error again in another AsyncError. </p>
<p>If the returned value is itself a Future, completion of the created future will wait until the returned future completes, and will then complete with the same result. </p>
<p>If a value is returned, it becomes the result of the created future.</p>
	</div>
	<b><a id=Future.delayed></a><i class=icon-plus-sign></i> factory Future.delayed(<a href=dart.core.html#Duration>Duration</a> duration, &lt;T&gt; computation)</b>
	<div class=indent>
		<p>Creates a future that completes after a delay. </p>
<p>The future will be completed after the given duration has passed with the result of calling computation. If the duration is 0 or less, it completes no sooner than in the next event-loop iteration. </p>
<p>If computation is not given or <code>null</code> then it will behave as if computation was set to <code>() =&gt; null</code>. That is, it will complete with <code>null</code>. </p>
<p>If calling computation throws, the created future will complete with the error. </p>
<p>See Completers, for futures with values that are computed asynchronously.</p>
	</div>
	<b><a id=Future.error></a><i class=icon-plus-sign></i> factory Future.error(dynamic error, <a href=dart.core.html#Object>Object</a> stackTrace)</b>
	<div class=indent>
		<p>A future that completes with an error in the next event-loop iteration. </p>
<p>See Completer to create a Future and complete it later.</p>
	</div>
	<b><a id=Future.sync></a><i class=icon-plus-sign></i> factory Future.sync(&lt;T&gt; computation)</b>
	<div class=indent>
		<p>Creates a future containing the result of immediately calling computation. </p>
<p>if the result of executing computation throws, the returned future is completed with the error. If a thrown value is an AsyncError, it is used directly, instead of wrapping this error again in another AsyncError. </p>
<p>If the returned value is itself a Future, completion of the created future will wait until the returned future completes, and will then complete with the same result.</p>
	</div>
	<b><a id=Future.value></a><i class=icon-plus-sign></i> factory Future.value(T value)</b>
	<div class=indent>
		<p>A future whose value is available in the next event-loop iteration. </p>
<p>If value is not a Future, using this constructor is equivalent to <code>new Future.sync(() =&gt; value)</code>. </p>
<p>See Completer to create a Future and complete it later.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=Future.asStream></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; asStream()</b>
	<div class=indent>
		<p>Creates a Stream that sends this' completion value, data or error, to its subscribers. The stream closes after the completion value.</p>
	</div>
	<b><a id=Future.catchError></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; catchError(&lt;T&gt; onError, &lt;T&gt; test)</b>
	<div class=indent>
		<p>Handles errors emitted by this Future. </p>
<p>Returns a new Future <code>f</code>. </p>
<p>When this completes with a value, the value is forwarded to <code>f</code> unmodified. That is, <code>f</code> completes with the same value. </p>
<p>When this completes with an error, test is called with the error's value. If the invocation returns true, onError is called with the error. The result of onError is handled exactly the same as for then's onError. </p>
<p>If test returns false, the exception is not handled by onError, but is thrown unmodified, thus forwarding it to <code>f</code>. </p>
<p>If test is omitted, it defaults to a function that always returns true. </p>
<p>Example: </p>
<p><pre>foo
  .catchError(..., test: (e) =&gt; e is ArgumentError)
  .catchError(..., test: (e) =&gt; e is NoSuchMethodError)
  .then((v) { ... });
</pre>This method is equivalent to: </p>
<p><pre>Future catchError(onError(error),
                  {bool test(error)}) {
  this.then((v) =&gt; v,  // Forward the value.
            // But handle errors, if the [test] succeeds.
            onError: (e) {
              if (test == null || test(e)) {
                return onError(e);
              }
              throw e;
            });
}
</pre></p>
	</div>
	<b><a id=Future.forEach></a><i class=icon-ok-sign></i> static <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; forEach(<a href=dart.core.html#Iterable>Iterable</a>&lt;dynamic&gt; input, &lt;T&gt; f)</b>
	<div class=indent>
		<p>Perform an async operation for each element of the iterable, in turn. </p>
<p>Runs f for each element in input in order, moving to the next element only when the Future returned by f completes. Returns a Future that completes when all elements have been processed. </p>
<p>The return values of all Futures are discarded. Any errors will cause the iteration to stop and will be piped through the returned Future.</p>
	</div>
	<b><a id=Future.then></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; then(&lt;T&gt; onValue, &lt;T&gt; onError)</b>
	<div class=indent>
		<p>When this future completes with a value, then onValue is called with this value. If this future is already completed then the invocation of onValue is delayed until the next event-loop iteration. </p>
<p>Returns a new Future <code>f</code> which is completed with the result of invoking onValue (if this completes with a value) or onError (if this completes with an error). </p>
<p>If the invoked callback throws an exception, the returned future <code>f</code> is completed with the error. </p>
<p>If the invoked callback returns a Future <code>f2</code> then <code>f</code> and <code>f2</code> are chained. That is, <code>f</code> is completed with the completion value of <code>f2</code>. </p>
<p>If onError is not given, it is equivalent to <code>(e) { throw e; }</code>. That is, it forwards the error to <code>f</code>. </p>
<p>In most cases, it is more readable to use catchError separately, possibly with a <code>test</code> parameter, instead of handling both value and error in a single then call.</p>
	</div>
	<b><a id=Future.wait></a><i class=icon-ok-sign></i> static <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#List>List</a>&lt;dynamic&gt;&gt; wait(<a href=dart.core.html#Iterable>Iterable</a>&lt;<a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;&gt; futures)</b>
	<div class=indent>
		<p>Wait for all the given futures to complete and collect their values. </p>
<p>Returns a future which will complete once all the futures in a list are complete. If any of the futures in the list completes with an error, the resulting future also completes with an error. Otherwise the value of the returned future will be a list of all the values that were produced.</p>
	</div>
	<b><a id=Future.whenComplete></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; whenComplete(&lt;T&gt; action)</b>
	<div class=indent>
		<p>Register a function to be called when this future completes. </p>
<p>The action function is called when this future completes, whether it does so with a value or with an error. </p>
<p>This is the asynchronous equivalent of a "finally" block. </p>
<p>The future returned by this call, <code>f</code>, will complete the same way as this future unless an error occurs in the action call, or in a Future returned by the action call. If the call to action does not return a future, its return value is ignored. </p>
<p>If the call to action throws, then <code>f</code> is completed with the thrown error. </p>
<p>If the call to action returns a Future, <code>f2</code>, then completion of <code>f</code> is delayed until <code>f2</code> completes. If <code>f2</code> completes with an error, that will be the result of <code>f</code> too. The value of <code>f2</code> is always ignored. </p>
<p>This method is equivalent to: </p>
<p><pre>Future&lt;T&gt; whenComplete(action()) {
  this.then((v) {
              var f2 = action();
              if (f2 is Future) return f2.then((_) =&gt; v);
              return v
            },
            onError: (e) {
              var f2 = action();
              if (f2 is Future) return f2.then((_) { throw e; });
              throw e;
            });
}
</pre></p>
	</div>
	<a id=Stream></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class Stream</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.first>first</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.isBroadcast>isBroadcast</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.isEmpty>isEmpty</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.last>last</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.length>length</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.single>single</a>: <a href=dart.async.html#Future>Future</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#first>first</a>: <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isBroadcast>isBroadcast</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isEmpty>isEmpty</a>: <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#last>last</a>: <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#length>length</a>: <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#int>int</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#single>single</a>: <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Stream.>Stream</a>()<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Stream.fromFuture>Stream.fromFuture</a>(<a href=dart.async.html#Future>Future</a>&lt;T&gt; future)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Stream.fromIterable>Stream.fromIterable</a>(<a href=dart.core.html#Iterable>Iterable</a>&lt;T&gt; data)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Stream.periodic>Stream.periodic</a>(<a href=dart.core.html#Duration>Duration</a> period, &lt;T&gt; computation)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.any>any</a>(&lt;T&gt; test): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.asBroadcastStream>asBroadcastStream</a>(&lt;T&gt; onListen, &lt;T&gt; onCancel): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.contains>contains</a>(<a href=dart.core.html#Object>Object</a> needle): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.distinct>distinct</a>(&lt;T&gt; equals): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.drain>drain</a>(dynamic futureValue): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.elementAt>elementAt</a>(<a href=dart.core.html#int>int</a> index): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.every>every</a>(&lt;T&gt; test): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.expand>expand</a>(&lt;T&gt; convert): <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.firstWhere>firstWhere</a>(&lt;T&gt; test, &lt;T&gt; defaultValue): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.fold>fold</a>(dynamic initialValue, &lt;T&gt; combine): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.forEach>forEach</a>(&lt;T&gt; action): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.handleError>handleError</a>(&lt;T&gt; handle, &lt;T&gt; test): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.join>join</a>(<a href=dart.core.html#String>String</a> separator): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#String>String</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.lastWhere>lastWhere</a>(&lt;T&gt; test, &lt;T&gt; defaultValue): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.listen>listen</a>(&lt;T&gt; onData, &lt;T&gt; onError, &lt;T&gt; onDone, <a href=dart.core.html#bool>bool</a> cancelOnError): <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.map>map</a>(&lt;T&gt; convert): <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.pipe>pipe</a>(<a href=dart.async.html#StreamConsumer>StreamConsumer</a>&lt;T&gt; streamConsumer): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.reduce>reduce</a>(&lt;T&gt; combine): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.singleWhere>singleWhere</a>(&lt;T&gt; test): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.skip>skip</a>(<a href=dart.core.html#int>int</a> count): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.skipWhile>skipWhile</a>(&lt;T&gt; test): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.take>take</a>(<a href=dart.core.html#int>int</a> count): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.takeWhile>takeWhile</a>(&lt;T&gt; test): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.toList>toList</a>(): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#List>List</a>&lt;T&gt;&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.toSet>toSet</a>(): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#Set>Set</a>&lt;T&gt;&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.transform>transform</a>(<a href=dart.async.html#StreamTransformer>StreamTransformer</a>&lt;T, dynamic&gt; streamTransformer): <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.where>where</a>(&lt;T&gt; test): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A source of asynchronous data events. </p>
<p>A Stream provides a sequence of events. Each event is either a data event or an error event, representing the result of a single computation. When the Stream is exhausted, it may send a single "done" event. </p>
<p>You can <a href=dart.async.html#Stream.listen>listen()</a> on a stream to receive the events it sends. When you listen, you receive a StreamSubscription object that can be used to stop listening, or to temporarily pause events from the stream. </p>
<p>When an event is fired, the listeners at that time are informed. If a listener is added while an event is being fired, the change will only take effect after the event is completely fired. If a listener is canceled, it immediately stops receiving events. </p>
<p>When the "done" event is fired, subscribers are unsubscribed before receiving the event. After the event has been sent, the stream has no subscribers. Adding new subscribers after this point is allowed, but they will just receive a new "done" event as soon as possible. </p>
<p>Streams always respect "pause" requests. If necessary they need to buffer their input, but often, and preferably, they can simply request their input to pause too. </p>
<p>There are two kinds of streams: The normal "single-subscription" streams and "broadcast" streams. </p>
<p>A single-subscription stream allows only a single listener at a time. It holds back events until it gets a listener, and it may exhaust itself when the listener is unsubscribed, even if the stream wasn't done. </p>
<p>Single-subscription streams are generally used for streaming parts of contiguous data like file I/O. </p>
<p>A broadcast stream allows any number of listeners, and it fires its events when they are ready, whether there are listeners or not. </p>
<p>Broadcast streams are used for independent events/observers. </p>
<p>The default implementation of <a href=dart.async.html#isBroadcast>isBroadcast</a> returns false. A broadcast stream inheriting from Stream must override <a href=dart.async.html#isBroadcast>isBroadcast</a> to return <code>true</code>.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=Stream.first></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> first</b>
	<div class=indent></div>
	<b><a id=Stream.isBroadcast></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isBroadcast</b>
	<div class=indent></div>
	<b><a id=Stream.isEmpty></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> isEmpty</b>
	<div class=indent></div>
	<b><a id=Stream.last></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> last</b>
	<div class=indent></div>
	<b><a id=Stream.length></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> length</b>
	<div class=indent></div>
	<b><a id=Stream.single></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> single</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=first></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; get first</b>
	<div class=indent>
		<p>Returns the first element of the stream. </p>
<p>Stops listening to the stream after the first element has been received. </p>
<p>If an error event occurs before the first data event, the resulting future is completed with that error. </p>
<p>If this stream is empty (a done event occurs before the first data event), the resulting future completes with a StateError. </p>
<p>Except for the type of the error, this method is equivalent to <code>this.elementAt(0)</code>.</p>
	</div>
	<b><a id=isBroadcast></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isBroadcast</b>
	<div class=indent>
		<p>Reports whether this stream is a broadcast stream.</p>
	</div>
	<b><a id=isEmpty></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; get isEmpty</b>
	<div class=indent>
		<p>Reports whether this stream contains any elements.</p>
	</div>
	<b><a id=last></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; get last</b>
	<div class=indent>
		<p>Returns the last element of the stream. </p>
<p>If an error event occurs before the first data event, the resulting future is completed with that error. </p>
<p>If this stream is empty (a done event occurs before the first data event), the resulting future completes with a StateError.</p>
	</div>
	<b><a id=length></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#int>int</a>&gt; get length</b>
	<div class=indent>
		<p>Counts the elements in the stream.</p>
	</div>
	<b><a id=single></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; get single</b>
	<div class=indent>
		<p>Returns the single element. </p>
<p>If this is empty or has more than one element throws a StateError.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Stream.></a><i class=icon-plus-sign></i> Stream()</b>
	<div class=indent></div>
	<b><a id=Stream.fromFuture></a><i class=icon-plus-sign></i> factory Stream.fromFuture(<a href=dart.async.html#Future>Future</a>&lt;T&gt; future)</b>
	<div class=indent>
		<p>Creates a new single-subscription stream from the future. </p>
<p>When the future completes, the stream will fire one event, either data or error, and then close with a done-event.</p>
	</div>
	<b><a id=Stream.fromIterable></a><i class=icon-plus-sign></i> factory Stream.fromIterable(<a href=dart.core.html#Iterable>Iterable</a>&lt;T&gt; data)</b>
	<div class=indent>
		<p>Creates a single-subscription stream that gets its data from data. </p>
<p>If iterating data throws an error, the stream ends immediately with that error. No done event will be sent (iteration is not complete), but no further data events will be generated either, since iteration cannot continue.</p>
	</div>
	<b><a id=Stream.periodic></a><i class=icon-plus-sign></i> factory Stream.periodic(<a href=dart.core.html#Duration>Duration</a> period, &lt;T&gt; computation)</b>
	<div class=indent>
		<p>Creates a stream that repeatedly emits events at period intervals. </p>
<p>The event values are computed by invoking computation. The argument to this callback is an integer that starts with 0 and is incremented for every event. </p>
<p>If computation is omitted the event values will all be <code>null</code>.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=Stream.any></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; any(&lt;T&gt; test)</b>
	<div class=indent>
		<p>Checks whether test accepts any element provided by this stream. </p>
<p>Completes the Future when the answer is known. If this stream reports an error, the Future will report that error.</p>
	</div>
	<b><a id=Stream.asBroadcastStream></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; asBroadcastStream(&lt;T&gt; onListen, &lt;T&gt; onCancel)</b>
	<div class=indent>
		<p>Returns a multi-subscription stream that produces the same events as this. </p>
<p>If this stream is already a broadcast stream, it is returned unmodified. </p>
<p>If this stream is single-subscription, return a new stream that allows multiple subscribers. It will subscribe to this stream when its first subscriber is added, and will stay subscribed until this stream ends, or a callback cancels the subscription. </p>
<p>If onListen is provided, it is called with a subscription-like object that represents the underlying subscription to this stream. It is possible to pause, resume or cancel the subscription during the call to onListen. It is not possible to change the event handlers, including using StreamSubscription.asFuture. </p>
<p>If onCancel is provided, it is called in a similar way to onListen when the returned stream stops having listener. If it later gets a new listener, the onListen function is called again. </p>
<p>Use the callbacks, for example, for pausing the underlying subscription while having no subscribers to prevent losing events, or canceling the subscription when there are no listeners.</p>
	</div>
	<b><a id=Stream.contains></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; contains(<a href=dart.core.html#Object>Object</a> needle)</b>
	<div class=indent>
		<p>Checks whether needle occurs in the elements provided by this stream. </p>
<p>Completes the Future when the answer is known. If this stream reports an error, the Future will report that error.</p>
	</div>
	<b><a id=Stream.distinct></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; distinct(&lt;T&gt; equals)</b>
	<div class=indent>
		<p>Skips data events if they are equal to the previous data event. </p>
<p>The returned stream provides the same events as this stream, except that it never provides two consequtive data events that are equal. </p>
<p>Equality is determined by the provided equals method. If that is omitted, the '==' operator on the last provided data element is used.</p>
	</div>
	<b><a id=Stream.drain></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; drain(dynamic futureValue)</b>
	<div class=indent>
		<p>Discards all data on the stream, but signals when it's done or an error occured. </p>
<p>When subscribing using drain, cancelOnError will be true. This means that the future will complete with the first error on the stream and then cancel the subscription. </p>
<p>In case of a <code>done</code> event the future completes with the given futureValue.</p>
	</div>
	<b><a id=Stream.elementAt></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; elementAt(<a href=dart.core.html#int>int</a> index)</b>
	<div class=indent>
		<p>Returns the value of the indexth data event of this stream. </p>
<p>Stops listening to the stream after a value has been found. </p>
<p>If an error event occurs before the value is found, the future completes with this error. </p>
<p>If a done event occurs before the value is found, the future completes with a RangeError.</p>
	</div>
	<b><a id=Stream.every></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; every(&lt;T&gt; test)</b>
	<div class=indent>
		<p>Checks whether test accepts all elements provided by this stream. </p>
<p>Completes the Future when the answer is known. If this stream reports an error, the Future will report that error.</p>
	</div>
	<b><a id=Stream.expand></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt; expand(&lt;T&gt; convert)</b>
	<div class=indent>
		<p>Creates a new stream from this stream that converts each element into zero or more events. </p>
<p>Each incoming event is converted to an Iterable of new events, and each of these new events are then sent by the returned stream in order.</p>
	</div>
	<b><a id=Stream.firstWhere></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; firstWhere(&lt;T&gt; test, &lt;T&gt; defaultValue)</b>
	<div class=indent>
		<p>Finds the first element of this stream matching test. </p>
<p>Returns a future that is filled with the first element of this stream that test returns true for. </p>
<p>If no such element is found before this stream is done, and a defaultValue function is provided, the result of calling defaultValue becomes the value of the future. </p>
<p>If an error occurs, or if this stream ends without finding a match and with no defaultValue function provided, the future will receive an error.</p>
	</div>
	<b><a id=Stream.fold></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; fold(dynamic initialValue, &lt;T&gt; combine)</b>
	<div class=indent>
		<p>Reduces a sequence of values by repeatedly applying combine.</p>
	</div>
	<b><a id=Stream.forEach></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; forEach(&lt;T&gt; action)</b>
	<div class=indent>
		<p>Executes action on each data event of the stream. </p>
<p>Completes the returned Future when all events of the stream have been processed. Completes the future with an error if the stream has an error event, or if action throws.</p>
	</div>
	<b><a id=Stream.handleError></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; handleError(&lt;T&gt; handle, &lt;T&gt; test)</b>
	<div class=indent>
		<p>Creates a wrapper Stream that intercepts some errors from this stream. </p>
<p>If this stream sends an error that matches test, then it is intercepted by the handle function. </p>
<p>An AsyncError <code>e</code> is matched by a test function if <code>test(e)</code> returns true. If test is omitted, every error is considered matching. </p>
<p>If the error is intercepted, the handle function can decide what to do with it. It can throw if it wants to raise a new (or the same) error, or simply return to make the stream forget the error. </p>
<p>If you need to transform an error into a data event, use the more generic Stream.transform to handle the event by writing a data event to the output sink</p>
	</div>
	<b><a id=Stream.join></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#String>String</a>&gt; join(<a href=dart.core.html#String>String</a> separator)</b>
	<div class=indent>
		<p>Collects string of data events' string representations. </p>
<p>If separator is provided, it is inserted between any two elements. </p>
<p>Any error in the stream causes the future to complete with that error. Otherwise it completes with the collected string when the "done" event arrives.</p>
	</div>
	<b><a id=Stream.lastWhere></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; lastWhere(&lt;T&gt; test, &lt;T&gt; defaultValue)</b>
	<div class=indent>
		<p>Finds the last element in this stream matching test. </p>
<p>As firstWhere, except that the last matching element is found. That means that the result cannot be provided before this stream is done.</p>
	</div>
	<b><a id=Stream.listen></a><i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt; listen(&lt;T&gt; onData, &lt;T&gt; onError, &lt;T&gt; onDone, <a href=dart.core.html#bool>bool</a> cancelOnError)</b>
	<div class=indent>
		<p>Adds a subscription to this stream. </p>
<p>On each data event from this stream, the subscriber's onData handler is called. If onData is null, nothing happens. </p>
<p>On errors from this stream, the onError handler is given a object describing the error. </p>
<p>If this stream closes, the onDone handler is called. </p>
<p>If cancelOnError is true, the subscription is ended when the first error is reported. The default is false.</p>
	</div>
	<b><a id=Stream.map></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt; map(&lt;T&gt; convert)</b>
	<div class=indent>
		<p>Creates a new stream that converts each element of this stream to a new value using the convert function.</p>
	</div>
	<b><a id=Stream.pipe></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; pipe(<a href=dart.async.html#StreamConsumer>StreamConsumer</a>&lt;T&gt; streamConsumer)</b>
	<div class=indent>
		<p>Binds this stream as the input of the provided StreamConsumer.</p>
	</div>
	<b><a id=Stream.reduce></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; reduce(&lt;T&gt; combine)</b>
	<div class=indent>
		<p>Reduces a sequence of values by repeatedly applying combine.</p>
	</div>
	<b><a id=Stream.singleWhere></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; singleWhere(&lt;T&gt; test)</b>
	<div class=indent>
		<p>Finds the single element in this stream matching test. </p>
<p>Like lastMatch, except that it is an error if more than one matching element occurs in the stream.</p>
	</div>
	<b><a id=Stream.skip></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; skip(<a href=dart.core.html#int>int</a> count)</b>
	<div class=indent>
		<p>Skips the first count data events from this stream.</p>
	</div>
	<b><a id=Stream.skipWhile></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; skipWhile(&lt;T&gt; test)</b>
	<div class=indent>
		<p>Skip data events from this stream while they are matched by test. </p>
<p>Error and done events are provided by the returned stream unmodified. </p>
<p>Starting with the first data event where test returns false for the event data, the returned stream will have the same events as this stream.</p>
	</div>
	<b><a id=Stream.take></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; take(<a href=dart.core.html#int>int</a> count)</b>
	<div class=indent>
		<p>Provides at most the first n values of this stream. </p>
<p>Forwards the first n data events of this stream, and all error events, to the returned stream, and ends with a done event. </p>
<p>If this stream produces fewer than count values before it's done, so will the returned stream.</p>
	</div>
	<b><a id=Stream.takeWhile></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; takeWhile(&lt;T&gt; test)</b>
	<div class=indent>
		<p>Forwards data events while test is successful. </p>
<p>The returned stream provides the same events as this stream as long as test returns <code>true</code> for the event data. The stream is done when either this stream is done, or when this stream first provides a value that test doesn't accept.</p>
	</div>
	<b><a id=Stream.toList></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#List>List</a>&lt;T&gt;&gt; toList()</b>
	<div class=indent>
		<p>Collects the data of this stream in a List.</p>
	</div>
	<b><a id=Stream.toSet></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#Set>Set</a>&lt;T&gt;&gt; toSet()</b>
	<div class=indent>
		<p>Collects the data of this stream in a Set.</p>
	</div>
	<b><a id=Stream.transform></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt; transform(<a href=dart.async.html#StreamTransformer>StreamTransformer</a>&lt;T, dynamic&gt; streamTransformer)</b>
	<div class=indent>
		<p>Chains this stream as the input of the provided StreamTransformer. </p>
<p>Returns the result of <code>streamTransformer.bind</code> itself.</p>
	</div>
	<b><a id=Stream.where></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; where(&lt;T&gt; test)</b>
	<div class=indent>
		<p>Creates a new stream from this stream that discards some data events. </p>
<p>The new stream sends the same error and done events as this stream, but it only sends the data events that satisfy the test.</p>
	</div>
	<a id=StreamConsumer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamConsumer</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamConsumer.>StreamConsumer</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamConsumer.addStream>addStream</a>(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; stream): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamConsumer.close>close</a>(): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>The target of a Stream.pipe call. </p>
<p>The Stream.pipe call will pass itself to this object, and then return the resulting Future. The pipe should complete the future when it's done.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamConsumer.></a><i class=icon-plus-sign></i> StreamConsumer()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamConsumer.addStream></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; addStream(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; stream)</b>
	<div class=indent></div>
	<b><a id=StreamConsumer.close></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; close()</b>
	<div class=indent></div>
	<a id=StreamController></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamController implements <a href=dart.async.html#StreamSink>StreamSink</a>&lt;T&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.hasListener>hasListener</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.isClosed>isClosed</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.isPaused>isPaused</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.sink>sink</a>: <a href=dart.async.html#StreamSink>StreamSink</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.stream>stream</a>: <a href=dart.async.html#Stream>Stream</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#hasListener>hasListener</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isClosed>isClosed</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isPaused>isPaused</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#sink>sink</a>: <a href=dart.async.html#StreamSink>StreamSink</a>&lt;T&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#stream>stream</a>: <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamController.>StreamController</a>(&lt;T&gt; onListen, &lt;T&gt; onPause, &lt;T&gt; onResume, &lt;T&gt; onCancel, <a href=dart.core.html#bool>bool</a> sync)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamController.broadcast>StreamController.broadcast</a>(&lt;T&gt; onListen, &lt;T&gt; onCancel, <a href=dart.core.html#bool>bool</a> sync)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamController.addError>addError</a>(<a href=dart.core.html#Object>Object</a> error, <a href=dart.core.html#Object>Object</a> stackTrace): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A controller with the stream it controls. </p>
<p>This controller allows sending data, error and done events on its <a href=dart.async.html#stream>stream</a>. This class can be used to create a simple stream that others can listen on, and to push events to that stream. </p>
<p>It's possible to check whether the stream is paused or not, and whether it has subscribers or not, as well as getting a callback when either of these change. </p>
<p>If the stream starts or stops having listeners (first listener subscribing, last listener unsubscribing), the <code>onSubscriptionStateChange</code> callback is notified as soon as possible. If the subscription stat changes during an event firing or a callback being executed, the change will not be reported until the current event or callback has finished. If the pause state has also changed during an event or callback, only the subscription state callback is notified. </p>
<p>If the subscriber state has not changed, but the pause state has, the <code>onPauseStateChange</code> callback is notified as soon as possible, after firing a current event or completing another callback. This happens if the stream is not paused, and a listener pauses it, or if the stream has been resumed from pause and has no pending events. If the listeners resume a paused stream while it still has queued events, the controller will still consider the stream paused until all queued events have been dispatched. </p>
<p>Whether to invoke a callback depends only on the state before and after a stream action, for example firing an event. If the state changes multiple times during the action, and then ends up in the same state as before, no callback is performed. </p>
<p>If listeners are added after the stream has completed (sent a "done" event), the listeners will be sent a "done" event eventually, but they won't affect the stream at all, and won't trigger callbacks. From the controller's point of view, the stream is completely inert when has completed.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamController.hasListener></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> hasListener</b>
	<div class=indent></div>
	<b><a id=StreamController.isClosed></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isClosed</b>
	<div class=indent></div>
	<b><a id=StreamController.isPaused></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isPaused</b>
	<div class=indent></div>
	<b><a id=StreamController.sink></a><i class=icon-minus-sign></i> final <a href=dart.async.html#StreamSink>StreamSink</a> sink</b>
	<div class=indent></div>
	<b><a id=StreamController.stream></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Stream>Stream</a> stream</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=hasListener></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get hasListener</b>
	<div class=indent>
		<p>Whether there is a subscriber on the Stream.</p>
	</div>
	<b><a id=isClosed></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isClosed</b>
	<div class=indent>
		<p>Whether the stream is closed for adding more events. </p>
<p>If true, the "done" event might not have fired yet, but it has been scheduled, and it is too late to add more events.</p>
	</div>
	<b><a id=isPaused></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isPaused</b>
	<div class=indent>
		<p>Whether the subscription would need to buffer events. </p>
<p>This is the case if the controller's stream has a listener and it is paused, or if it has not received a listener yet. In that case, the controller is considered paused as well. </p>
<p>A broadcast stream controller is never considered paused. It always forwards its events to all uncanceled listeners, if any, and let them handle their own pausing.</p>
	</div>
	<b><a id=sink></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#StreamSink>StreamSink</a>&lt;T&gt; get sink</b>
	<div class=indent>
		<p>Returns a view of this object that only exposes the StreamSink interface.</p>
	</div>
	<b><a id=stream></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; get stream</b>
	<div class=indent>
		<p>The stream that this controller is controlling.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamController.></a><i class=icon-plus-sign></i> factory StreamController(&lt;T&gt; onListen, &lt;T&gt; onPause, &lt;T&gt; onResume, &lt;T&gt; onCancel, <a href=dart.core.html#bool>bool</a> sync)</b>
	<div class=indent>
		<p>A controller with a stream that supports only one single subscriber. </p>
<p>If sync is true, events may be passed directly to the stream's listener during an add, addError or close call. If sync is false, the event will be passed to the listener at a later time, after the code creating the event has returned. </p>
<p>The controller will buffer all incoming events until the subscriber is registered. </p>
<p>The onPause function is called when the stream becomes paused. onResume is called when the stream resumed. </p>
<p>The onListen callback is called when the stream receives its listener and onCancel when the listener ends its subscription. </p>
<p>If the stream is canceled before the controller needs new data the onResume call might not be executed.</p>
	</div>
	<b><a id=StreamController.broadcast></a><i class=icon-plus-sign></i> factory StreamController.broadcast(&lt;T&gt; onListen, &lt;T&gt; onCancel, <a href=dart.core.html#bool>bool</a> sync)</b>
	<div class=indent>
		<p>A controller where stream can be listened to more than once. </p>
<p>The Stream returned by stream is a broadcast stream. It can be listened to more than once. </p>
<p>The controller distributes any events to all currently subscribed listeners. It is not allowed to call add, addError, or close before a previous call has returned. </p>
<p>If sync is true, events may be passed directly to the stream's listener during an add, addError or close call. If sync is false, the event will be passed to the listener at a later time, after the code creating the event has returned. </p>
<p>Each listener is handled independently, and if they pause, only the pausing listener is affected. A paused listener will buffer events internally until unpaused or canceled. </p>
<p>If sync is false, no guarantees are given with regard to when multiple listeners get the events, except that each listener will get all events in the correct order. If two events are sent on an async controller with two listeners, one of the listeners may get both events before the other listener gets any. A listener must be subscribed both when the event is initiated (that is, when add is called) and when the event is later delivered, in order to get the event. </p>
<p>The onListen callback is called when the first listener is subscribed, and the onCancel is called when there are no longer any active listeners. If a listener is added again later, after the onCancel was called, the onListen will be called again.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=StreamController.addError></a><i class=icon-ok-sign></i> <a href='dart.async.html#EventSink.addError'><i title='Overrides EventSink.addError()' class='icon-circle-arrow-up'></i></a> void addError(<a href=dart.core.html#Object>Object</a> error, <a href=dart.core.html#Object>Object</a> stackTrace)</b>
	<div class=indent>
		<p>Send or enqueue an error event. </p>
<p>Also allows an objection stack trace object, on top of what EventSink allows.</p>
	</div>
	<a id=StreamEventTransformer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamEventTransformer implements <a href=dart.async.html#StreamTransformer>StreamTransformer</a>&lt;S, T&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamEventTransformer.>StreamEventTransformer</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamEventTransformer.bind>bind</a>(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; source): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamEventTransformer.handleData>handleData</a>(S event, <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamEventTransformer.handleDone>handleDone</a>(<a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamEventTransformer.handleError>handleError</a>(dynamic error, <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Base class for transformers that modifies stream events. </p>
<p>A StreamEventTransformer transforms incoming Stream events of one kind into outgoing events of (possibly) another kind. </p>
<p>Subscribing on the stream returned by <a href=dart.async.html#StreamEventTransformer.bind>bind()</a> is the same as subscribing on the source stream, except that events are passed through the transformer before being emitted. The transformer may generate any number and types of events for each incoming event. Pauses on the returned subscription are forwarded to this stream. </p>
<p>An example that duplicates all data events: </p>
<p><pre>class DoubleTransformer&lt;T&gt; extends StreamEventTransformer&lt;T, T&gt; {
  void handleData(T data, EventSink&lt;T&gt; sink) {
    sink.add(value);
    sink.add(value);
  }
}
someTypeStream.transform(new DoubleTransformer&lt;Type&gt;());
</pre>The default implementations of the "handle" methods forward the events unmodified. If using the default <a href=dart.async.html#StreamEventTransformer.handleData>handleData()</a> the generic type T needs to be assignable to S.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamEventTransformer.></a><i class=icon-plus-sign></i> StreamEventTransformer()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamEventTransformer.bind></a><i class=icon-ok-sign></i> <a href='dart.async.html#StreamTransformer.bind'><i title='Overrides StreamTransformer.bind()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; bind(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; source)</b>
	<div class=indent></div>
	<b><a id=StreamEventTransformer.handleData></a><i class=icon-ok-sign></i> void handleData(S event, <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink)</b>
	<div class=indent>
		<p>Act on incoming data event. </p>
<p>The method may generate any number of events on the sink, but should not throw.</p>
	</div>
	<b><a id=StreamEventTransformer.handleDone></a><i class=icon-ok-sign></i> void handleDone(<a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink)</b>
	<div class=indent>
		<p>Act on incoming done event. </p>
<p>The method may generate any number of events on the sink, but should not throw.</p>
	</div>
	<b><a id=StreamEventTransformer.handleError></a><i class=icon-ok-sign></i> void handleError(dynamic error, <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink)</b>
	<div class=indent>
		<p>Act on incoming error event. </p>
<p>The method may generate any number of events on the sink, but should not throw.</p>
	</div>
	<a id=StreamIterator></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamIterator</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamIterator.current>current</a>: <a href=dart.async.html#T>T</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#current>current</a>: T<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamIterator.>StreamIterator</a>(<a href=dart.async.html#Stream>Stream</a>&lt;T&gt; stream)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamIterator.cancel>cancel</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamIterator.moveNext>moveNext</a>(): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>An Iterable like interface for the values of a Stream. </p>
<p>This wraps a Stream and a subscription on the stream. It listens on the stream, and completes the future returned by <a href=dart.async.html#StreamIterator.moveNext>moveNext()</a> when the next value becomes available. </p>
<p>NOTICE: This is a tentative design. This class may change.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamIterator.current></a><i class=icon-minus-sign></i> final <a href=dart.async.html#T>T</a> current</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=current></a><i class=icon-circle-arrow-right></i> T get current</b>
	<div class=indent>
		<p>The current value of the stream. </p>
<p>Only valid when the future returned by moveNext completes with <code>true</code> as value, and only until the next call to moveNext.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamIterator.></a><i class=icon-plus-sign></i> factory StreamIterator(<a href=dart.async.html#Stream>Stream</a>&lt;T&gt; stream)</b>
	<div class=indent>
		<p>Create a StreamIterator on stream.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=StreamIterator.cancel></a><i class=icon-ok-sign></i> void cancel()</b>
	<div class=indent>
		<p>Cancels the stream iterator (and the underlying stream subscription) early. </p>
<p>The stream iterator is automatically canceled if the moveNext future completes with either <code>false</code> or an error. </p>
<p>If a moveNext call has been made, it will complete with <code>false</code> as value, as will all further calls to moveNext. </p>
<p>If you need to stop listening for values before the stream iterator is automatically closed, you must call cancel to ensure that the stream is properly closed.</p>
	</div>
	<b><a id=StreamIterator.moveNext></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; moveNext()</b>
	<div class=indent>
		<p>Wait for the next stream value to be available. </p>
<p>It is not allowed to call this function again until the future has completed. If the returned future completes with anything except <code>true</code>, the iterator is done, and no new value will ever be available. </p>
<p>The future may complete with an error, if the stream produces an error.</p>
	</div>
	<a id=StreamSink></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamSink implements <a href=dart.async.html#StreamConsumer>StreamConsumer</a>&lt;S&gt;, <a href=dart.async.html#EventSink>EventSink</a>&lt;S&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamSink.done>done</a>: <a href=dart.async.html#Future>Future</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#done>done</a>: <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamSink.>StreamSink</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSink.close>close</a>(): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A StreamSink unifies the asynchronous methods from StreamConsumer and the synchronous methods from EventSink. </p>
<p>The EventSink methods can't be used while the addStream is called. As soon as the addStream's Future completes with a value, the EventSink methods can be used again. </p>
<p>If addStream is called after any of the EventSink methods, it'll be delayed until the underlying system has consumed the data added by the EventSink methods. </p>
<p>When EventSink methods are used, the <a href=dart.async.html#done>done</a> Future can be used to catch any errors. </p>
<p>When <a href=dart.async.html#StreamSink.close>close()</a> is called, it will return the <a href=dart.async.html#done>done</a> Future.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamSink.done></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> done</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=done></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; get done</b>
	<div class=indent>
		<p>The done Future completes with the same values as close, except for the following case: </p>
<p><ul><li>The synchronous methods of EventSink were called, resulting in an</li></ul>error. If there is no active future (like from an addStream call), the done future will complete with that error</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamSink.></a><i class=icon-plus-sign></i> StreamSink()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamSink.close></a><i class=icon-ok-sign></i> <a href='dart.async.html#StreamConsumer.close'><i title='Overrides StreamConsumer.close()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; close()</b>
	<div class=indent>
		<p>Close the StreamSink. It'll return the done Future.</p>
	</div>
	<a id=StreamSubscription></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamSubscription</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamSubscription.isPaused>isPaused</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isPaused>isPaused</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamSubscription.>StreamSubscription</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.asFuture>asFuture</a>(dynamic futureValue): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.cancel>cancel</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.onData>onData</a>(&lt;T&gt; handleData): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.onDone>onDone</a>(&lt;T&gt; handleDone): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.onError>onError</a>(&lt;T&gt; handleError): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.pause>pause</a>(<a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; resumeSignal): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.resume>resume</a>(): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A control object for the subscription on a Stream. </p>
<p>When you subscribe on a Stream using Stream.listen, a StreamSubscription object is returned. This object is used to later unsubscribe again, or to temporarily pause the stream's events.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamSubscription.isPaused></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isPaused</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=isPaused></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isPaused</b>
	<div class=indent>
		<p>Returns true if the StreamSubscription is paused.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamSubscription.></a><i class=icon-plus-sign></i> StreamSubscription()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamSubscription.asFuture></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; asFuture(dynamic futureValue)</b>
	<div class=indent>
		<p>Returns a future that handles the onDone and onError callbacks. </p>
<p>This method <i>overwrites</i> the existing onDone and onError callbacks with new ones that complete the returned future. </p>
<p>In case of an error the subscription will automatically cancel (even when it was listening with <code>cancelOnError</code> set to <code>false</code>). </p>
<p>In case of a <code>done</code> event the future completes with the given futureValue.</p>
	</div>
	<b><a id=StreamSubscription.cancel></a><i class=icon-ok-sign></i> void cancel()</b>
	<div class=indent>
		<p>Cancels this subscription. It will no longer receive events. </p>
<p>If an event is currently firing, this unsubscription will only take effect after all subscribers have received the current event.</p>
	</div>
	<b><a id=StreamSubscription.onData></a><i class=icon-ok-sign></i> void onData(&lt;T&gt; handleData)</b>
	<div class=indent>
		<p>Set or override the data event handler of this subscription.</p>
	</div>
	<b><a id=StreamSubscription.onDone></a><i class=icon-ok-sign></i> void onDone(&lt;T&gt; handleDone)</b>
	<div class=indent>
		<p>Set or override the done event handler of this subscription.</p>
	</div>
	<b><a id=StreamSubscription.onError></a><i class=icon-ok-sign></i> void onError(&lt;T&gt; handleError)</b>
	<div class=indent>
		<p>Set or override the error event handler of this subscription.</p>
	</div>
	<b><a id=StreamSubscription.pause></a><i class=icon-ok-sign></i> void pause(<a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; resumeSignal)</b>
	<div class=indent>
		<p>Request that the stream pauses events until further notice. </p>
<p>If resumeSignal is provided, the stream will undo the pause when the future completes. If the future completes with an error, it will not be handled! </p>
<p>A call to resume will also undo a pause. </p>
<p>If the subscription is paused more than once, an equal number of resumes must be performed to resume the stream.</p>
	</div>
	<b><a id=StreamSubscription.resume></a><i class=icon-ok-sign></i> void resume()</b>
	<div class=indent>
		<p>Resume after a pause.</p>
	</div>
	<a id=StreamTransformer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamTransformer</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamTransformer.>StreamTransformer</a>(&lt;S, T&gt; handleData, &lt;S, T&gt; handleError, &lt;S, T&gt; handleDone)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamTransformer.bind>bind</a>(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; stream): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>The target of a Stream.transform call. </p>
<p>The Stream.transform call will pass itself to this object and then return the resulting stream.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamTransformer.></a><i class=icon-plus-sign></i> factory StreamTransformer(&lt;S, T&gt; handleData, &lt;S, T&gt; handleError, &lt;S, T&gt; handleDone)</b>
	<div class=indent>
		<p>Create a StreamTransformer that delegates events to the given functions. </p>
<p>This is actually a StreamEventTransformer where the event handling is performed by the function arguments. If an argument is omitted, it acts as the corresponding default method from StreamEventTransformer. </p>
<p>Example use: </p>
<p><pre>stringStream.transform(new StreamTransformer&lt;String, String&gt;(
    handleData: (String value, EventSink&lt;String&gt; sink) {
      sink.add(value);
      sink.add(value);  // Duplicate the incoming events.
    }));
</pre></p>
	</div>
	<h4>Methods</h4>
	<b><a id=StreamTransformer.bind></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; bind(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; stream)</b>
	<div class=indent></div>
	<a id=StreamView></a><hr>
	<h4>
		<i class=icon-leaf></i> Class StreamView extends <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamView.isBroadcast>isBroadcast</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isBroadcast>isBroadcast</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamView.>StreamView</a>(<a href=dart.async.html#Stream>Stream</a>&lt;T&gt; _stream)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamView.asBroadcastStream>asBroadcastStream</a>(&lt;T&gt; onListen, &lt;T&gt; onCancel): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamView.listen>listen</a>(&lt;T&gt; onData, &lt;T&gt; onError, &lt;T&gt; onDone, <a href=dart.core.html#bool>bool</a> cancelOnError): <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Stream wrapper that only exposes the Stream interface.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamView.isBroadcast></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isBroadcast</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=isBroadcast></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isBroadcast</b>
	<div class=indent></div>
	<h4>Constructors</h4>
	<b><a id=StreamView.></a><i class=icon-plus-sign></i> StreamView(<a href=dart.async.html#Stream>Stream</a>&lt;T&gt; _stream)</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamView.asBroadcastStream></a><i class=icon-ok-sign></i> <a href='dart.async.html#Stream.asBroadcastStream'><i title='Overrides Stream.asBroadcastStream()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; asBroadcastStream(&lt;T&gt; onListen, &lt;T&gt; onCancel)</b>
	<div class=indent>
		<p>Returns a multi-subscription stream that produces the same events as this. </p>
<p>If this stream is already a broadcast stream, it is returned unmodified. </p>
<p>If this stream is single-subscription, return a new stream that allows multiple subscribers. It will subscribe to this stream when its first subscriber is added, and will stay subscribed until this stream ends, or a callback cancels the subscription. </p>
<p>If onListen is provided, it is called with a subscription-like object that represents the underlying subscription to this stream. It is possible to pause, resume or cancel the subscription during the call to onListen. It is not possible to change the event handlers, including using StreamSubscription.asFuture. </p>
<p>If onCancel is provided, it is called in a similar way to onListen when the returned stream stops having listener. If it later gets a new listener, the onListen function is called again. </p>
<p>Use the callbacks, for example, for pausing the underlying subscription while having no subscribers to prevent losing events, or canceling the subscription when there are no listeners.</p>
	</div>
	<b><a id=StreamView.listen></a><i class=icon-ok-sign></i> <a href='dart.async.html#Stream.listen'><i title='Overrides Stream.listen()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt; listen(&lt;T&gt; onData, &lt;T&gt; onError, &lt;T&gt; onDone, <a href=dart.core.html#bool>bool</a> cancelOnError)</b>
	<div class=indent>
		<p>Adds a subscription to this stream. </p>
<p>On each data event from this stream, the subscriber's onData handler is called. If onData is null, nothing happens. </p>
<p>On errors from this stream, the onError handler is given a object describing the error. </p>
<p>If this stream closes, the onDone handler is called. </p>
<p>If cancelOnError is true, the subscription is ended when the first error is reported. The default is false.</p>
	</div>
	<a id=Timer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class Timer</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Timer.isActive>isActive</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isActive>isActive</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Timer.>Timer</a>(<a href=dart.core.html#Duration>Duration</a> duration,  callback)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Timer.periodic>Timer.periodic</a>(<a href=dart.core.html#Duration>Duration</a> duration,  callback)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Timer.cancel>cancel</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Timer.run>run</a>( callback): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A count-down timer that can be configured to fire once or repeatedly. </p>
<p>The timer counts down from the specified duration to 0. When the timer reaches 0, the timer invokes the specified callback function. Use a periodic timer to repeatedly count down the same interval. </p>
<p>A negative duration is treated the same as a duration of 0. If the duration is statically known to be 0, consider using <a href=dart.async.html#Timer.run>run()</a>. </p>
<p>Frequently the duration is either a constant or computed as in the following example (taking advantage of the multiplication operator of the Duration class): </p>
<p><pre>const TIMEOUT = const Duration(seconds: 3);
const ms = const Duration(milliseconds: 1);

startTimeout([int milliseconds]) {
  var duration = milliseconds == null ? TIMEOUT : ms * milliseconds;
  return new Timer(duration, handleTimeout);
}
...
void handleTimeout() {  // callback function
  ...
}
</pre>Note: If Dart code using Timer is compiled to JavaScript, the finest granularity available in the browser is 4 milliseconds. </p>
<p>See Stopwatch for measuring elapsed time.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=Timer.isActive></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isActive</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=isActive></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isActive</b>
	<div class=indent>
		<p>Returns whether the timer is still active. </p>
<p>A non-periodic timer is active if the callback has not been executed, and the timer has not been canceled. </p>
<p>A periodic timer is active if it has not been canceled.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Timer.></a><i class=icon-plus-sign></i> factory Timer(<a href=dart.core.html#Duration>Duration</a> duration,  callback)</b>
	<div class=indent>
		<p>Creates a new timer. </p>
<p>The callback function is invoked after the given duration.</p>
	</div>
	<b><a id=Timer.periodic></a><i class=icon-plus-sign></i> factory Timer.periodic(<a href=dart.core.html#Duration>Duration</a> duration,  callback)</b>
	<div class=indent>
		<p>Creates a new repeating timer. </p>
<p>The callback is invoked repeatedly with duration intervals until canceled with the cancel function.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=Timer.cancel></a><i class=icon-ok-sign></i> void cancel()</b>
	<div class=indent>
		<p>Cancels the timer.</p>
	</div>
	<b><a id=Timer.run></a><i class=icon-ok-sign></i> static void run( callback)</b>
	<div class=indent>
		<p>Runs the given callback asynchronously as soon as possible. </p>
<p>This function is equivalent to <code>new Timer(Duration.ZERO, callback)</code>.</p>
	</div>
	<hr>
</div>
</div>
</div>
<footer>
</footer>
</body>
</html>
