<!DOCTYPE html>

<!-- generated by papyrus on 9/7/2013 -->

<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Library dart.mirrors</title>
	<link href="bootstrap.css" rel="stylesheet" media="screen">
</head>

<body>
<header>
</header>
<div class='container'>
<div class='row'>
<div class='span3'>
	<ul class="nav nav-tabs nav-stacked left-nav">
		<li><a href="chrome.html"><i class="chevron-nav icon-chevron-right"></i> chrome</a></li>
		<li><a href="dart.async.html"><i class="chevron-nav icon-chevron-right"></i> dart.async</a></li>
		<li><a href="dart.collection.html"><i class="chevron-nav icon-chevron-right"></i> dart.collection</a></li>
		<li><a href="dart.convert.html"><i class="chevron-nav icon-chevron-right"></i> dart.convert</a></li>
		<li><a href="dart.core.html"><i class="chevron-nav icon-chevron-right"></i> dart.core</a></li>
		<li><a href="dart.dom.html.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.html</a></li>
		<li><a href="dart.dom.indexed_db.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.indexed_db</a></li>
		<li><a href="dart.dom.svg.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.svg</a></li>
		<li><a href="dart.dom.web_audio.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.web_audio</a></li>
		<li><a href="dart.dom.web_gl.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.web_gl</a></li>
		<li><a href="dart.dom.web_sql.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.web_sql</a></li>
		<li><a href="dart.io.html"><i class="chevron-nav icon-chevron-right"></i> dart.io</a></li>
		<li><a href="dart.isolate.html"><i class="chevron-nav icon-chevron-right"></i> dart.isolate</a></li>
		<li><a href="dart.js.html"><i class="chevron-nav icon-chevron-right"></i> dart.js</a></li>
		<li><a href="dart.json.html"><i class="chevron-nav icon-chevron-right"></i> dart.json</a></li>
		<li><a href="dart.math.html"><i class="chevron-nav icon-chevron-right"></i> dart.math</a></li>
		<li class="active"><a href="dart.mirrors.html"><i class="chevron-nav icon-white icon-chevron-right"></i> dart.mirrors</a></li>
		<li><a href="dart.typed_data.html"><i class="chevron-nav icon-chevron-right"></i> dart.typed_data</a></li>
		<li><a href="dart.utf.html"><i class="chevron-nav icon-chevron-right"></i> dart.utf</a></li>
	</ul>
</div>
<div class='span9'>
	<h1>dart.mirrors</h1>
	<hr>
	<dl class=dl-horizontal>
		<dt>Functions</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#currentMirrorSystem>currentMirrorSystem</a>(): <a href=dart.mirrors.html#MirrorSystem>MirrorSystem</a><br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#mirrorSystemOf>mirrorSystemOf</a>(<a href=dart.isolate.html#SendPort>SendPort</a> port): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#MirrorSystem>MirrorSystem</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#reflect>reflect</a>(<a href=dart.core.html#Object>Object</a> reflectee): <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#reflectClass>reflectClass</a>(<a href=dart.core.html#Type>Type</a> key): <a href=dart.mirrors.html#ClassMirror>ClassMirror</a><br>
		</dd>
		<dt>Classes</dt>
		<dd>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#ClassMirror>ClassMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#ClosureMirror>ClosureMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#Comment>Comment</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#DeclarationMirror>DeclarationMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#FunctionTypeMirror>FunctionTypeMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#IsolateMirror>IsolateMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#LibraryMirror>LibraryMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#MethodMirror>MethodMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#Mirror>Mirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#MirrorException>MirrorException</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#MirrorSystem>MirrorSystem</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#MirroredCompilationError>MirroredCompilationError</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#MirroredError>MirroredError</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#MirroredUncaughtExceptionError>MirroredUncaughtExceptionError</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#MirrorsUsed>MirrorsUsed</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#ObjectMirror>ObjectMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#ParameterMirror>ParameterMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#SourceLocation>SourceLocation</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#TypeVariableMirror>TypeVariableMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#TypedefMirror>TypedefMirror</a><br>
			<i class=icon-leaf></i> <a href=dart.mirrors.html#VariableMirror>VariableMirror</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>Basic reflection in Dart, with support for introspection and dynamic evaluation. </p>
<p><i>Introspection</i> is that subset of reflection by which a running program can examine its own structure. For example, a function that prints out the names of all the members of an arbitrary object. </p>
<p><i>Dynamic evaluation</i> refers the ability to evaluate code that has not been literally specified at compile time, such as calling a method whose name is provided as an argument (because it is looked up in a database, or provided interactively by the user). </p>
<p><h5> How to interpret this library's documentation</h5> </p>
<p>As a rule, the names of Dart declarations are represented using instances of class Symbol. Whenever the doc speaks of an object <i>s</i> of class Symbol denoting a name, it means the string that was used to construct <i>s</i>. </p>
<p>The documentation frequently abuses notation with Dart pseudo-code such as <code>o.x(a)</code>, where o and a are defined to be objects; what is actually meant in these cases is <code>o'.x(a')</code> where <i>o'</i> and <i>a'</i> are Dart variables bound to <i>o</i> and <i>a</i> respectively. Furthermore, <i>o'</i> and <i>a'</i> are assumed to be fresh variables (meaning that they are distinct from any other variables in the program). </p>
<p>Sometimes the documentation refers to <i>serializable</i> objects. An object is serializable across isolates if and only if it is an instance of num, bool, String, a list of objects that are serializable across isolates, or a map with keys and values that are all serializable across isolates.</p>
	</div>
	<h4>Functions</h4>
	<div class=indent>
		<b><a id=currentMirrorSystem></a><i class=icon-ok-sign></i> static <a href=dart.mirrors.html#MirrorSystem>MirrorSystem</a> currentMirrorSystem()</b>
		<div class=indent>
			<p>Returns a MirrorSystem for the current isolate.</p>
		</div>
		<b><a id=mirrorSystemOf></a><i class=icon-ok-sign></i> static <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#MirrorSystem>MirrorSystem</a>&gt; mirrorSystemOf(<a href=dart.isolate.html#SendPort>SendPort</a> port)</b>
		<div class=indent>
			<p>Creates a MirrorSystem for the isolate which is listening on the SendPort.</p>
		</div>
		<b><a id=reflect></a><i class=icon-ok-sign></i> static <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> reflect(<a href=dart.core.html#Object>Object</a> reflectee)</b>
		<div class=indent>
			<p>Returns an InstanceMirror reflecting reflectee. If reflectee is function or an instance of a class that has a <code>call</code> method, the returned instance mirror will be a ClosureMirror. </p>
<p>Note that since one cannot obtain an object from another isolate, this function can only be used to obtain  mirrors on objects of the current isolate.</p>
		</div>
		<b><a id=reflectClass></a><i class=icon-ok-sign></i> static <a href=dart.mirrors.html#ClassMirror>ClassMirror</a> reflectClass(<a href=dart.core.html#Type>Type</a> key)</b>
		<div class=indent>
			<p>Let <i>C</i> be the original class declaration of the class represented by key. This function returns a ClassMirror reflecting <i>C</i>. </p>
<p>If key is not an instance of Type then this function throws an ArgumentError. If key is the Type dynamic, throws an ArgumentError because dynamic is not a class. </p>
<p>Note that since one cannot obtain a Type object from another isolate, this function can only be used to obtain class mirrors on classes of the current isolate.</p>
		</div>
	</div>
	<a id=ClassMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class ClassMirror implements <a href=dart.mirrors.html#TypeMirror>TypeMirror</a>, <a href=dart.mirrors.html#ObjectMirror>ObjectMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.constructors>constructors</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.getters>getters</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.hasReflectedType>hasReflectedType</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.isOriginalDeclaration>isOriginalDeclaration</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.members>members</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.methods>methods</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.originalDeclaration>originalDeclaration</a>: <a href=dart.mirrors.html#ClassMirror>ClassMirror</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.reflectedType>reflectedType</a>: <a href=dart.core.html#Type>Type</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.setters>setters</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.superclass>superclass</a>: <a href=dart.mirrors.html#ClassMirror>ClassMirror</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.superinterfaces>superinterfaces</a>: <a href=dart.core.html#List>List</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.typeArguments>typeArguments</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.typeVariables>typeVariables</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClassMirror.variables>variables</a>: <a href=dart.core.html#Map>Map</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#constructors>constructors</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#getters>getters</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#hasReflectedType>hasReflectedType</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isOriginalDeclaration>isOriginalDeclaration</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#members>members</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#Mirror>Mirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#methods>methods</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#originalDeclaration>originalDeclaration</a>: <a href=dart.mirrors.html#ClassMirror>ClassMirror</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#reflectedType>reflectedType</a>: <a href=dart.core.html#Type>Type</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#setters>setters</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#superclass>superclass</a>: <a href=dart.mirrors.html#ClassMirror>ClassMirror</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#superinterfaces>superinterfaces</a>: <a href=dart.core.html#List>List</a>&lt;<a href=dart.mirrors.html#ClassMirror>ClassMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#typeArguments>typeArguments</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#TypeMirror>TypeMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#typeVariables>typeVariables</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#TypeVariableMirror>TypeVariableMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#variables>variables</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#VariableMirror>VariableMirror</a>&gt;<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#ClassMirror.>ClassMirror</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ClassMirror.==>==</a>(dynamic other): <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ClassMirror.newInstance>newInstance</a>(<a href=dart.core.html#Symbol>Symbol</a> constructorName, <a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments): <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ClassMirror.newInstanceAsync>newInstanceAsync</a>(<a href=dart.core.html#Symbol>Symbol</a> constructorName, <a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A ClassMirror reflects a Dart language class.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=ClassMirror.constructors></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> constructors</b>
	<div class=indent></div>
	<b><a id=ClassMirror.getters></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> getters</b>
	<div class=indent></div>
	<b><a id=ClassMirror.hasReflectedType></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> hasReflectedType</b>
	<div class=indent></div>
	<b><a id=ClassMirror.isOriginalDeclaration></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isOriginalDeclaration</b>
	<div class=indent></div>
	<b><a id=ClassMirror.members></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> members</b>
	<div class=indent></div>
	<b><a id=ClassMirror.methods></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> methods</b>
	<div class=indent></div>
	<b><a id=ClassMirror.originalDeclaration></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#ClassMirror>ClassMirror</a> originalDeclaration</b>
	<div class=indent></div>
	<b><a id=ClassMirror.reflectedType></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Type>Type</a> reflectedType</b>
	<div class=indent></div>
	<b><a id=ClassMirror.setters></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> setters</b>
	<div class=indent></div>
	<b><a id=ClassMirror.superclass></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#ClassMirror>ClassMirror</a> superclass</b>
	<div class=indent></div>
	<b><a id=ClassMirror.superinterfaces></a><i class=icon-minus-sign></i> final <a href=dart.core.html#List>List</a> superinterfaces</b>
	<div class=indent></div>
	<b><a id=ClassMirror.typeArguments></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> typeArguments</b>
	<div class=indent></div>
	<b><a id=ClassMirror.typeVariables></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> typeVariables</b>
	<div class=indent></div>
	<b><a id=ClassMirror.variables></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> variables</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=constructors></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt; get constructors</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all constructor declarations for this type.</p>
	</div>
	<b><a id=getters></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt; get getters</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all getter declarations for this type.</p>
	</div>
	<b><a id=hasReflectedType></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get hasReflectedType</b>
	<div class=indent>
		<p>Returns true if this mirror reflects a non-generic class or an instantiated generic class in the current isolate. Otherwise, returns false.</p>
	</div>
	<b><a id=isOriginalDeclaration></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isOriginalDeclaration</b>
	<div class=indent>
		<p>Is this the original declaration of this type? </p>
<p>For most classes, they are their own original declaration.  For generic classes, however, there is a distinction between the original class declaration, which has unbound type variables, and the instantiations of generic classes, which have bound type variables.</p>
	</div>
	<b><a id=members></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#Mirror>Mirror</a>&gt; get members</b>
	<div class=indent>
		<p>An immutable map from from names to mirrors for all members of this type. </p>
<p>The members of a type are its methods, fields, getters, and setters.  Note that constructors and type variables are not considered to be members of a type. </p>
<p>This does not include inherited members.</p>
	</div>
	<b><a id=methods></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt; get methods</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all method, declarations for this type.  This does not include getters and setters.</p>
	</div>
	<b><a id=originalDeclaration></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#ClassMirror>ClassMirror</a> get originalDeclaration</b>
	<div class=indent>
		<p>A mirror on the original declaration of this type. </p>
<p>For most classes, they are their own original declaration.  For generic classes, however, there is a distinction between the original class declaration, which has unbound type variables, and the instantiations of generic classes, which have bound type variables.</p>
	</div>
	<b><a id=reflectedType></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Type>Type</a> get reflectedType</b>
	<div class=indent>
		<p>If <code>hasReflectedType</code> returns true, returns the corresponding Type. Otherwise, an UnsupportedError is thrown.</p>
	</div>
	<b><a id=setters></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt; get setters</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all setter declarations for this type.</p>
	</div>
	<b><a id=superclass></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#ClassMirror>ClassMirror</a> get superclass</b>
	<div class=indent>
		<p>A mirror on the superclass on the reflectee. </p>
<p>If this type is <code>Object</code> or a typedef, the superClass will be null.</p>
	</div>
	<b><a id=superinterfaces></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#List>List</a>&lt;<a href=dart.mirrors.html#ClassMirror>ClassMirror</a>&gt; get superinterfaces</b>
	<div class=indent>
		<p>A list of mirrors on the superinterfaces of the reflectee.</p>
	</div>
	<b><a id=typeArguments></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#TypeMirror>TypeMirror</a>&gt; get typeArguments</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all type arguments for this type.  The keys of the map are the names of the corresponding type variables. </p>
<p>If the the reflectee is an invocation of a generic class, the type arguments are the bindings of its type parameters. If the reflectee is the original declaration of a generic, it has no type arguments and this method returns an empty map. If the reflectee is a not generic, then it has no type arguments and this method returns an empty map. This map preserves the order of declaration of the type variables.</p>
	</div>
	<b><a id=typeVariables></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#TypeVariableMirror>TypeVariableMirror</a>&gt; get typeVariables</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all type variables for this type. If this type is a generic declaration or an invocation of a generic declaration, the returned map has the names of the formal type parameters of the original declaration as its keys, and each such key maps to a TypeVariableMirror on the corresponding type variable. Otherwise, the returned map is empty. </p>
<p>This map preserves the order of declaration of the type variables.</p>
	</div>
	<b><a id=variables></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#VariableMirror>VariableMirror</a>&gt; get variables</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all variable declarations for this type.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=ClassMirror.></a><i class=icon-plus-sign></i> ClassMirror()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=ClassMirror.==></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.=='><i title='Overrides Object.==()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#bool>bool</a> ==(dynamic other)</b>
	<div class=indent>
		<p>Returns <code>true</code> if this mirror is equal to other. Otherwise returns <code>false</code>. </p>
<p>The equality holds if and only if (1) other is a mirror of the same kind and (2) This mirror and other reflect the same class. </p>
<p>Note that if the reflected class is an invocation of a generic class,(2) implies that the reflected class and other have equal type arguments.</p>
	</div>
	<b><a id=ClassMirror.newInstance></a><i class=icon-ok-sign></i> <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> newInstance(<a href=dart.core.html#Symbol>Symbol</a> constructorName, <a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments)</b>
	<div class=indent>
		<p>Invokes the named constructor and returns a mirror on the result. </p>
<p>Let <i>c</i> be the class reflected by this mirror let <i>a1, ..., an</i> be the elements of positionalArguments let <i>k1, ..., km</i> be the identifiers denoted by the elements of namedArguments.keys and let <i>v1, ..., vm</i> be the elements of namedArguments.values. If constructorName was created from the empty string Then this method will execute the instance creation expression <i>new c(a1, ..., an, k1: v1, ..., km: vm)</i> in a scope that has access to the private members of <i>c</i>. Otherwise, let <i>f</i> be the simple name of the constructor denoted by constructorName Then this method will execute the instance creation expression <i>new c.f(a1, ..., an, k1: v1, ..., km: vm)</i> in a scope that has access to the private members of <i>c</i>. In either case: If the expression evaluates to a result <i>r</i>, this method returns the result of calling reflect(<i>r</i>). If evaluating the expression causes a compilation error this method throws a MirroredCompilationError. If evaluating the expression throws an exception <i>e</i> (that it does not catch) this method throws <i>e</i>.</p>
	</div>
	<b><a id=ClassMirror.newInstanceAsync></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt; newInstanceAsync(<a href=dart.core.html#Symbol>Symbol</a> constructorName, <a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments)</b>
	<div class=indent>
		<p>Invokes the named function and returns a mirror on the result. The arguments must be instances of InstanceMirror, or of a type that is serializable across isolates (currently num, String, or bool). </p>
<p>Let <i>c</i> be the class reflected by this mirror, let <i>a1, ..., an</i> be the elements of positionalArguments let <i>k1, ..., km</i> be the identifiers denoted by the elements of namedArguments.keys and let <i>v1, ..., vm</i> be the elements of namedArguments.values. For each <i>ai</i>, if <i>ai</i> is an instance of InstanceMirror, let <i>pi</i> be the object reflected by <i>ai</i>; otherwise let <i>pi = ai,  i in 1 ...n</i>. Likewise, for each <i>vj</i>, if <i>vj</i> is an instance of InstanceMirror, let <i>qj</i> be the object reflected by <i>vj</i>; otherwise let <i>qj = vj,  j in 1 ...m</i>. If any of the <i>pi, qj</i> is not an instance of InstanceMirror and is not serializable across isolates, an exception is thrown. If constructorName was created from the empty string Then this method will execute the instance creation expression <i>new c(a1, ..., an, k1: v1, ..., km: vm)</i> in a scope that has access to the private members of <i>c</i>. Otherwise, let <i>f</i> be the simple name of the constructor denoted by constructorName Then this method will execute the instance creation expression <i>new c.f(a1, ..., an, k1: v1, ..., km: vm)</i> in a scope that has access to the private members of <i>c</i>. In either case: The method returns a future <i>k</i>. If the invocation returns a result <i>r</i>, <i>k</i> will be completed with the result of calling reflect(<i>r</i>). If the invocation throws an exception <i>e</i> (that it does not catch) then <i>k</i> is completed with a MirrorError wrapping <i>e</i>.</p>
	</div>
	<a id=ClosureMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class ClosureMirror implements <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ClosureMirror.function>function</a>: <a href=dart.mirrors.html#MethodMirror>MethodMirror</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#function>function</a>: <a href=dart.mirrors.html#MethodMirror>MethodMirror</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#ClosureMirror.>ClosureMirror</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ClosureMirror.apply>apply</a>(<a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments): <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ClosureMirror.applyAsync>applyAsync</a>(<a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ClosureMirror.findInContext>findInContext</a>(<a href=dart.core.html#Symbol>Symbol</a> name): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A ClosureMirror reflects a closure. </p>
<p>A ClosureMirror provides access to its captured variables and provides the ability to execute its reflectee.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=ClosureMirror.function></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#MethodMirror>MethodMirror</a> function</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=function></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#MethodMirror>MethodMirror</a> get function</b>
	<div class=indent>
		<p>A mirror on the function associated with this closure.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=ClosureMirror.></a><i class=icon-plus-sign></i> ClosureMirror()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=ClosureMirror.apply></a><i class=icon-ok-sign></i> <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> apply(<a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments)</b>
	<div class=indent>
		<p>Executes the closure and returns a mirror on the result. Let <i>f</i> be the closure reflected by this mirror, let <i>a1, ..., an</i> be the elements of positionalArguments let <i>k1, ..., km</i> be the identifiers denoted by the elements of namedArguments.keys and let <i>v1, ..., vm</i> be the elements of namedArguments.values. Then this method will perform the method invocation <i>f(a1, ..., an, k1: v1, ..., km: vm)</i> If the invocation returns a result <i>r</i>, this method returns the result of calling reflect(<i>r</i>). If the invocation causes a compilation error this method throws a MirrorError. If the invocation throws an exception <i>e</i> (that it does not catch) this method throws <i>e</i>.</p>
	</div>
	<b><a id=ClosureMirror.applyAsync></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt; applyAsync(<a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments)</b>
	<div class=indent>
		<p>Executes the closure and returns a mirror on the result. </p>
<p>Let <i>f</i> be the closure reflected by this mirror, let <i>a1, ..., an</i> be the elements of positionalArguments let <i>k1, ..., km</i> be the identifiers denoted by the elements of namedArguments.keys and let <i>v1, ..., vm</i> be the elements of namedArguments.values. For each <i>ai</i>, if <i>ai</i> is an instance of InstanceMirror, let <i>pi</i> be the object reflected by <i>ai</i>; otherwise let <i>pi = ai,  i in 1 ...n</i>. Likewise, for each <i>vj</i>, if <i>vj</i> is an instance of InstanceMirror, let <i>qj</i> be the object reflected by <i>vj</i>; otherwise let <i>qj = vj,  j in 1 ...m</i>. If any of the <i>pi, qj</i> is not an instance of InstanceMirror and is not serializable across isolates, an exception is thrown. Then this method will perform the function invocation <i>f(p1, ..., pn, k1: q1, ..., km: qm)</i> The method returns a future <i>k</i>. If the invocation returns a result <i>r</i>, <i>k</i> will be completed with the result of calling reflect(<i>r</i>). If the invocation throws an exception <i>e</i> (that it does not catch) then <i>k</i> is completed with a MirrorError wrapping <i>e</i>. </p>
<p>The arguments must be instances of InstanceMirror, or of a type that is serializable across isolates (currently num, String, or bool).</p>
	</div>
	<b><a id=ClosureMirror.findInContext></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt; findInContext(<a href=dart.core.html#Symbol>Symbol</a> name)</b>
	<div class=indent>
		<p>Looks up the value of a name in the scope of the closure. The result is a mirror on that value. </p>
<p>Let <i>s</i> be the contents of the string used to construct the symbol name. </p>
<p>If the expression <i>s</i> occurs within the source code of the reflectee, and that any such occurrence refers to a declaration outside the reflectee, then let <i>v</i> be the result of evaluating the expression <i>s</i> at such an occurrence. If <i>s = this</i>, and the reflectee was defined within the instance scope of an object <i>o</i>, then let <i>v</i> be <i>o</i>. </p>
<p>The returned value is the result of invoking the method reflect on <i>v</i>.</p>
	</div>
	<a id=Comment></a><hr>
	<h4>
		<i class=icon-leaf></i> Class Comment</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#Comment.isDocComment>isDocComment</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#Comment.text>text</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#Comment.trimmedText>trimmedText</a>: <a href=dart.core.html#String>String</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#Comment.>Comment</a>(<a href=dart.core.html#String>String</a> text, <a href=dart.core.html#String>String</a> trimmedText, <a href=dart.core.html#bool>bool</a> isDocComment)<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Class used for encoding comments as metadata annotations.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=Comment.isDocComment></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isDocComment</b>
	<div class=indent>
		<p>Is <code>true</code> if this comment is a documentation comment. </p>
<p>That is, that the comment is either enclosed in <code> /<i></i> ... */ </code> or starts with <code> /// </code>.</p>
	</div>
	<b><a id=Comment.text></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> text</b>
	<div class=indent>
		<p>The comment text as written in the source text.</p>
	</div>
	<b><a id=Comment.trimmedText></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> trimmedText</b>
	<div class=indent>
		<p>The comment text without the start, end, and padding text. </p>
<p>For example, if text is <code> /<i></i> Comment text. */ </code> then the trimmedText is <code> Comment text. </code>.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Comment.></a><i class=icon-plus-sign></i> Comment(<a href=dart.core.html#String>String</a> text, <a href=dart.core.html#String>String</a> trimmedText, <a href=dart.core.html#bool>bool</a> isDocComment)</b>
	<div class=indent></div>
	<a id=DeclarationMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class DeclarationMirror implements <a href=dart.mirrors.html#Mirror>Mirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#DeclarationMirror.isPrivate>isPrivate</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#DeclarationMirror.isTopLevel>isTopLevel</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#DeclarationMirror.location>location</a>: <a href=dart.mirrors.html#SourceLocation>SourceLocation</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#DeclarationMirror.metadata>metadata</a>: <a href=dart.core.html#List>List</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#DeclarationMirror.owner>owner</a>: <a href=dart.mirrors.html#DeclarationMirror>DeclarationMirror</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#DeclarationMirror.qualifiedName>qualifiedName</a>: <a href=dart.core.html#Symbol>Symbol</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#DeclarationMirror.simpleName>simpleName</a>: <a href=dart.core.html#Symbol>Symbol</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isPrivate>isPrivate</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isTopLevel>isTopLevel</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#location>location</a>: <a href=dart.mirrors.html#SourceLocation>SourceLocation</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#metadata>metadata</a>: <a href=dart.core.html#List>List</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#owner>owner</a>: <a href=dart.mirrors.html#DeclarationMirror>DeclarationMirror</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#qualifiedName>qualifiedName</a>: <a href=dart.core.html#Symbol>Symbol</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#simpleName>simpleName</a>: <a href=dart.core.html#Symbol>Symbol</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#DeclarationMirror.>DeclarationMirror</a>()<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A DeclarationMirror reflects some entity declared in a Dart program.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=DeclarationMirror.isPrivate></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isPrivate</b>
	<div class=indent></div>
	<b><a id=DeclarationMirror.isTopLevel></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isTopLevel</b>
	<div class=indent></div>
	<b><a id=DeclarationMirror.location></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#SourceLocation>SourceLocation</a> location</b>
	<div class=indent></div>
	<b><a id=DeclarationMirror.metadata></a><i class=icon-minus-sign></i> final <a href=dart.core.html#List>List</a> metadata</b>
	<div class=indent></div>
	<b><a id=DeclarationMirror.owner></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#DeclarationMirror>DeclarationMirror</a> owner</b>
	<div class=indent></div>
	<b><a id=DeclarationMirror.qualifiedName></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Symbol>Symbol</a> qualifiedName</b>
	<div class=indent></div>
	<b><a id=DeclarationMirror.simpleName></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Symbol>Symbol</a> simpleName</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=isPrivate></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isPrivate</b>
	<div class=indent>
		<p>Returns <code>true</code> if this declaration is considered private according to the Dart language specification. Always returns <code> false </code> if this declaration is a library. Otherwise return <code>false</code>.</p>
	</div>
	<b><a id=isTopLevel></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isTopLevel</b>
	<div class=indent>
		<p>Is this declaration top-level? </p>
<p>This is defined to be equivalent to: <code>mirror.owner != null &amp;&amp; mirror.owner is LibraryMirror</code></p>
	</div>
	<b><a id=location></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#SourceLocation>SourceLocation</a> get location</b>
	<div class=indent>
		<p>The source location of this Dart language entity.</p>
	</div>
	<b><a id=metadata></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#List>List</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt; get metadata</b>
	<div class=indent>
		<p>A list of the metadata associated with this declaration. </p>
<p>Let <i>D</i> be the declaration this mirror reflects. If <i>D</i> is decorated with annotations <i>A1, ..., An</i> where <i>n &gt; 0</i>, then for each annotation <i>Ai</i> associated with <i>D, 1 &lt;= i &lt;= n</i>, let <i>ci</i> be the constant object specified by <i>Ai</i>. Then this method returns a list whose members are instance mirrors on <i>c1, ..., cn</i>. If no annotations are associated with <i>D</i>, then an empty list is returned.</p>
	</div>
	<b><a id=owner></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#DeclarationMirror>DeclarationMirror</a> get owner</b>
	<div class=indent>
		<p>A mirror on the owner of this Dart language entity. This is the declaration immediately surrounding the reflectee. </p>
<p>For a library, the owner is <code>null</code>. For a class declaration, typedef or top level function or variable, the owner is the enclosing library. For a mixin application <i>S with M</i>, the owner is the owner of <i>M</i>. For class Null, the owner is the dart:core library. For a constructor, the owner is the immediately enclosing class. For a method, instance variable or a static variable, the owner is the immediately enclosing class, unless the class is a mixin application <i>S with M</i>, in which case the owner is <i>M</i>. Note that <i>M</i> may be an invocation of a generic. For a parameter, local variable or local function the owner is the immediately enclosing function.</p>
	</div>
	<b><a id=qualifiedName></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Symbol>Symbol</a> get qualifiedName</b>
	<div class=indent>
		<p>The fully-qualified name for this Dart language entity. </p>
<p>This name is qualified by the name of the owner. For instance, the qualified name of a method 'method' in class 'Class' in library 'library' is 'library.Class.method'. </p>
<p>Returns a Symbol constructed from a string representing the fully qualified name of the reflectee. Let <i>o</i> be the owner of this mirror, let <i>r</i> be the reflectee of this mirror, let <i>p</i> be the fully qualified name of the reflectee of <i>o</i>, and let <i>s</i> be the simple name of <i>r</i> computed by simpleName. The fully qualified name of <i>r</i> is the concatenation of <i>p</i>, '.', and <i>s</i>. </p>
<p>Because an isolate can contain more than one library with the same name (at different URIs), a fully-qualified name does not uniquely identify any language entity.</p>
	</div>
	<b><a id=simpleName></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Symbol>Symbol</a> get simpleName</b>
	<div class=indent>
		<p>The simple name for this Dart language entity. </p>
<p>The simple name is in most cases the the identifier name of the entity, such as 'method' for a method <code>void method() {...}</code> or 'mylibrary' for a <code>library 'mylibrary';</code> declaration.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=DeclarationMirror.></a><i class=icon-plus-sign></i> DeclarationMirror()</b>
	<div class=indent></div>
	<a id=FunctionTypeMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class FunctionTypeMirror implements <a href=dart.mirrors.html#ClassMirror>ClassMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#FunctionTypeMirror.callMethod>callMethod</a>: <a href=dart.mirrors.html#MethodMirror>MethodMirror</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#FunctionTypeMirror.parameters>parameters</a>: <a href=dart.core.html#List>List</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#FunctionTypeMirror.returnType>returnType</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#callMethod>callMethod</a>: <a href=dart.mirrors.html#MethodMirror>MethodMirror</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#parameters>parameters</a>: <a href=dart.core.html#List>List</a>&lt;<a href=dart.mirrors.html#ParameterMirror>ParameterMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#returnType>returnType</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#FunctionTypeMirror.>FunctionTypeMirror</a>()<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A FunctionTypeMirror represents the type of a function in the Dart language.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=FunctionTypeMirror.callMethod></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#MethodMirror>MethodMirror</a> callMethod</b>
	<div class=indent></div>
	<b><a id=FunctionTypeMirror.parameters></a><i class=icon-minus-sign></i> final <a href=dart.core.html#List>List</a> parameters</b>
	<div class=indent></div>
	<b><a id=FunctionTypeMirror.returnType></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> returnType</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=callMethod></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#MethodMirror>MethodMirror</a> get callMethod</b>
	<div class=indent>
		<p>A mirror on the <code>call</code> method for the reflectee.</p>
	</div>
	<b><a id=parameters></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#List>List</a>&lt;<a href=dart.mirrors.html#ParameterMirror>ParameterMirror</a>&gt; get parameters</b>
	<div class=indent>
		<p>Returns a list of the parameter types of the reflectee.</p>
	</div>
	<b><a id=returnType></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> get returnType</b>
	<div class=indent>
		<p>Returns the return type of the reflectee.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=FunctionTypeMirror.></a><i class=icon-plus-sign></i> FunctionTypeMirror()</b>
	<div class=indent></div>
	<a id=InstanceMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class InstanceMirror implements <a href=dart.mirrors.html#ObjectMirror>ObjectMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#InstanceMirror.hasReflectee>hasReflectee</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#InstanceMirror.reflectee>reflectee</a>: dynamic<br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#InstanceMirror.type>type</a>: <a href=dart.mirrors.html#ClassMirror>ClassMirror</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#hasReflectee>hasReflectee</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#reflectee>reflectee</a>: dynamic<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#type>type</a>: <a href=dart.mirrors.html#ClassMirror>ClassMirror</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#InstanceMirror.>InstanceMirror</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#InstanceMirror.==>==</a>(dynamic other): <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#InstanceMirror.delegate>delegate</a>(<a href=dart.core.html#Invocation>Invocation</a> invocation): dynamic<br>
		</dd>
	</dl>
	<div class=indent>
		<p>An InstanceMirror reflects an instance of a Dart language object.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=InstanceMirror.hasReflectee></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> hasReflectee</b>
	<div class=indent></div>
	<b><a id=InstanceMirror.reflectee></a><i class=icon-minus-sign></i> final dynamic reflectee</b>
	<div class=indent></div>
	<b><a id=InstanceMirror.type></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#ClassMirror>ClassMirror</a> type</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=hasReflectee></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get hasReflectee</b>
	<div class=indent>
		<p>Does reflectee contain the instance reflected by this mirror? This will always be true in the local case (reflecting instances in the same isolate), but only true in the remote case if this mirror reflects a simple value. </p>
<p>A value is simple if one of the following holds: - the value is <code>null</code> - the value is of type num - the value is of type bool - the value is of type String</p>
	</div>
	<b><a id=reflectee></a><i class=icon-circle-arrow-right></i> dynamic get reflectee</b>
	<div class=indent>
		<p>If the InstanceMirror reflects an instance it is meaningful to have a local reference to, we provide access to the actual instance here. </p>
<p>If you access reflectee when hasReflectee is false, an exception is thrown.</p>
	</div>
	<b><a id=type></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#ClassMirror>ClassMirror</a> get type</b>
	<div class=indent>
		<p>A mirror on the type of the reflectee. </p>
<p>Returns a mirror on the actual class of the reflectee. The class of the reflectee may differ from the object returned by invoking runtimeType on the reflectee.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=InstanceMirror.></a><i class=icon-plus-sign></i> InstanceMirror()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=InstanceMirror.==></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.=='><i title='Overrides Object.==()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#bool>bool</a> ==(dynamic other)</b>
	<div class=indent>
		<p>Returns true if this mirror is equal to other. The equality holds if and only if (1) other is a mirror of the same kind and (2) either (a) hasReflectee is true and so is <code>identical(reflectee, other.reflectee)</code> or (b) the remote objects reflected by this mirror and by other are identical.</p>
	</div>
	<b><a id=InstanceMirror.delegate></a><i class=icon-ok-sign></i> dynamic delegate(<a href=dart.core.html#Invocation>Invocation</a> invocation)</b>
	<div class=indent>
		<p>Perform invocation on reflectee. Equivalent to </p>
<p>this.invoke(invocation.memberName, <pre>        invocation.positionalArguments,
        invocation.namedArguments);
</pre></p>
	</div>
	<a id=IsolateMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class IsolateMirror implements <a href=dart.mirrors.html#Mirror>Mirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#IsolateMirror.debugName>debugName</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#IsolateMirror.isCurrent>isCurrent</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#IsolateMirror.rootLibrary>rootLibrary</a>: <a href=dart.mirrors.html#LibraryMirror>LibraryMirror</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#debugName>debugName</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isCurrent>isCurrent</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#rootLibrary>rootLibrary</a>: <a href=dart.mirrors.html#LibraryMirror>LibraryMirror</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#IsolateMirror.>IsolateMirror</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#IsolateMirror.==>==</a>(dynamic other): <a href=dart.core.html#bool>bool</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>An IsolateMirror reflects an isolate.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=IsolateMirror.debugName></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> debugName</b>
	<div class=indent></div>
	<b><a id=IsolateMirror.isCurrent></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isCurrent</b>
	<div class=indent></div>
	<b><a id=IsolateMirror.rootLibrary></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#LibraryMirror>LibraryMirror</a> rootLibrary</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=debugName></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#String>String</a> get debugName</b>
	<div class=indent>
		<p>Returns a unique name used to refer to an isolate in debugging messages.</p>
	</div>
	<b><a id=isCurrent></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isCurrent</b>
	<div class=indent>
		<p>Returns <code>true</code> if and only if this mirror reflects the currently running isolate. Otherwise returns <code>false</code>.</p>
	</div>
	<b><a id=rootLibrary></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#LibraryMirror>LibraryMirror</a> get rootLibrary</b>
	<div class=indent>
		<p>Returns a LibraryMirror on the root library for this isolate.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=IsolateMirror.></a><i class=icon-plus-sign></i> IsolateMirror()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=IsolateMirror.==></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.=='><i title='Overrides Object.==()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#bool>bool</a> ==(dynamic other)</b>
	<div class=indent>
		<p>Returns <code>true</code> if this mirror is equal to other. Otherwise returns <code>false</code>. The equality holds if and only if (1) other is a mirror of the same kind and (2) the isolate being reflected by this mirror is the same isolate being reflected by other.</p>
	</div>
	<a id=LibraryMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class LibraryMirror implements <a href=dart.mirrors.html#DeclarationMirror>DeclarationMirror</a>, <a href=dart.mirrors.html#ObjectMirror>ObjectMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#LibraryMirror.classes>classes</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#LibraryMirror.functions>functions</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#LibraryMirror.getters>getters</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#LibraryMirror.members>members</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#LibraryMirror.setters>setters</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#LibraryMirror.uri>uri</a>: <a href=dart.core.html#Uri>Uri</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#LibraryMirror.variables>variables</a>: <a href=dart.core.html#Map>Map</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#classes>classes</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#ClassMirror>ClassMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#functions>functions</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#getters>getters</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#members>members</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#Mirror>Mirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#setters>setters</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#uri>uri</a>: <a href=dart.core.html#Uri>Uri</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#variables>variables</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#VariableMirror>VariableMirror</a>&gt;<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#LibraryMirror.>LibraryMirror</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#LibraryMirror.==>==</a>(dynamic other): <a href=dart.core.html#bool>bool</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>A LibraryMirror reflects a Dart language library, providing access to the variables, functions, and classes of the library.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=LibraryMirror.classes></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> classes</b>
	<div class=indent></div>
	<b><a id=LibraryMirror.functions></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> functions</b>
	<div class=indent></div>
	<b><a id=LibraryMirror.getters></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> getters</b>
	<div class=indent></div>
	<b><a id=LibraryMirror.members></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> members</b>
	<div class=indent></div>
	<b><a id=LibraryMirror.setters></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> setters</b>
	<div class=indent></div>
	<b><a id=LibraryMirror.uri></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Uri>Uri</a> uri</b>
	<div class=indent></div>
	<b><a id=LibraryMirror.variables></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> variables</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=classes></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#ClassMirror>ClassMirror</a>&gt; get classes</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all class declarations in this library.</p>
	</div>
	<b><a id=functions></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt; get functions</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all function, getter, and setter declarations in this library.</p>
	</div>
	<b><a id=getters></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt; get getters</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all getter declarations in this library.</p>
	</div>
	<b><a id=members></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#Mirror>Mirror</a>&gt; get members</b>
	<div class=indent>
		<p>An immutable map from from names to mirrors for all members in this library. </p>
<p>The members of a library are its top-level classes, functions, variables, getters, and setters.</p>
	</div>
	<b><a id=setters></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#MethodMirror>MethodMirror</a>&gt; get setters</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all setter declarations in this library.</p>
	</div>
	<b><a id=uri></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Uri>Uri</a> get uri</b>
	<div class=indent>
		<p>The absolute uri of the library.</p>
	</div>
	<b><a id=variables></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, <a href=dart.mirrors.html#VariableMirror>VariableMirror</a>&gt; get variables</b>
	<div class=indent>
		<p>An immutable map from names to mirrors for all variable declarations in this library.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=LibraryMirror.></a><i class=icon-plus-sign></i> LibraryMirror()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=LibraryMirror.==></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.=='><i title='Overrides Object.==()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#bool>bool</a> ==(dynamic other)</b>
	<div class=indent>
		<p>Returns <code>true</code> if this mirror is equal to other. Otherwise returns <code>false</code>. </p>
<p>The equality holds if and only if (1) other is a mirror of the same kind and (2)  The library being reflected by this mirror and the library being reflected by other are the same library in the same isolate.</p>
	</div>
	<a id=MethodMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class MethodMirror implements <a href=dart.mirrors.html#DeclarationMirror>DeclarationMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.constructorName>constructorName</a>: <a href=dart.core.html#Symbol>Symbol</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isAbstract>isAbstract</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isConstConstructor>isConstConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isConstructor>isConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isFactoryConstructor>isFactoryConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isGenerativeConstructor>isGenerativeConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isGetter>isGetter</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isOperator>isOperator</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isRedirectingConstructor>isRedirectingConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isRegularMethod>isRegularMethod</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isSetter>isSetter</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.isStatic>isStatic</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.parameters>parameters</a>: <a href=dart.core.html#List>List</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.returnType>returnType</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MethodMirror.source>source</a>: <a href=dart.core.html#String>String</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#constructorName>constructorName</a>: <a href=dart.core.html#Symbol>Symbol</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isAbstract>isAbstract</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isConstConstructor>isConstConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isConstructor>isConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isFactoryConstructor>isFactoryConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isGenerativeConstructor>isGenerativeConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isGetter>isGetter</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isOperator>isOperator</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isRedirectingConstructor>isRedirectingConstructor</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isRegularMethod>isRegularMethod</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isSetter>isSetter</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isStatic>isStatic</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#parameters>parameters</a>: <a href=dart.core.html#List>List</a>&lt;<a href=dart.mirrors.html#ParameterMirror>ParameterMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#returnType>returnType</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#source>source</a>: <a href=dart.core.html#String>String</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#MethodMirror.>MethodMirror</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#MethodMirror.==>==</a>(dynamic other): <a href=dart.core.html#bool>bool</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>A MethodMirror reflects a Dart language function, method, constructor, getter, or setter.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=MethodMirror.constructorName></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Symbol>Symbol</a> constructorName</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isAbstract></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isAbstract</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isConstConstructor></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isConstConstructor</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isConstructor></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isConstructor</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isFactoryConstructor></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isFactoryConstructor</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isGenerativeConstructor></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isGenerativeConstructor</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isGetter></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isGetter</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isOperator></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isOperator</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isRedirectingConstructor></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isRedirectingConstructor</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isRegularMethod></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isRegularMethod</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isSetter></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isSetter</b>
	<div class=indent></div>
	<b><a id=MethodMirror.isStatic></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isStatic</b>
	<div class=indent></div>
	<b><a id=MethodMirror.parameters></a><i class=icon-minus-sign></i> final <a href=dart.core.html#List>List</a> parameters</b>
	<div class=indent></div>
	<b><a id=MethodMirror.returnType></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> returnType</b>
	<div class=indent></div>
	<b><a id=MethodMirror.source></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> source</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=constructorName></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Symbol>Symbol</a> get constructorName</b>
	<div class=indent>
		<p>The constructor name for named constructors and factory methods. </p>
<p>For unnamed constructors, this is the empty string.  For non-constructors, this is the empty string. </p>
<p>For example, <code>'bar'</code> is the constructor name for constructor <code>Foo.bar</code> of type <code>Foo</code>.</p>
	</div>
	<b><a id=isAbstract></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isAbstract</b>
	<div class=indent>
		<p>Is the reflectee abstract?</p>
	</div>
	<b><a id=isConstConstructor></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isConstConstructor</b>
	<div class=indent>
		<p>Is the reflectee a const constructor?</p>
	</div>
	<b><a id=isConstructor></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isConstructor</b>
	<div class=indent>
		<p>Is the reflectee a constructor?</p>
	</div>
	<b><a id=isFactoryConstructor></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isFactoryConstructor</b>
	<div class=indent>
		<p>Is the reflectee a factory constructor?</p>
	</div>
	<b><a id=isGenerativeConstructor></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isGenerativeConstructor</b>
	<div class=indent>
		<p>Is the reflectee a generative constructor?</p>
	</div>
	<b><a id=isGetter></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isGetter</b>
	<div class=indent>
		<p>Is the reflectee a getter?</p>
	</div>
	<b><a id=isOperator></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isOperator</b>
	<div class=indent>
		<p>Is the reflectee an operator?</p>
	</div>
	<b><a id=isRedirectingConstructor></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isRedirectingConstructor</b>
	<div class=indent>
		<p>Is the reflectee a redirecting constructor?</p>
	</div>
	<b><a id=isRegularMethod></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isRegularMethod</b>
	<div class=indent>
		<p>Is the reflectee a regular function or method? </p>
<p>A function or method is regular if it is not a getter, setter, or constructor.  Note that operators, by this definition, are regular methods.</p>
	</div>
	<b><a id=isSetter></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isSetter</b>
	<div class=indent>
		<p>Is the reflectee a setter?</p>
	</div>
	<b><a id=isStatic></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isStatic</b>
	<div class=indent>
		<p>Is the reflectee static? </p>
<p>For the purposes of the mirrors library, a top-level function is considered static.</p>
	</div>
	<b><a id=parameters></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#List>List</a>&lt;<a href=dart.mirrors.html#ParameterMirror>ParameterMirror</a>&gt; get parameters</b>
	<div class=indent>
		<p>A list of mirrors on the parameters for the reflectee.</p>
	</div>
	<b><a id=returnType></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> get returnType</b>
	<div class=indent>
		<p>A mirror on the return type for the reflectee.</p>
	</div>
	<b><a id=source></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#String>String</a> get source</b>
	<div class=indent>
		<p>The source code for the reflectee, if available. Otherwise null.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=MethodMirror.></a><i class=icon-plus-sign></i> MethodMirror()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=MethodMirror.==></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.=='><i title='Overrides Object.==()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#bool>bool</a> ==(dynamic other)</b>
	<div class=indent>
		<p>Returns true if this mirror is equal to other. </p>
<p>The equality holds if and only if (1) other is a mirror of the same kind and (2) <code>simpleName == other.simpleName</code> and <code>owner == other.owner</code>.</p>
	</div>
	<a id=Mirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class Mirror</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#Mirror.mirrors>mirrors</a>: <a href=dart.mirrors.html#MirrorSystem>MirrorSystem</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#mirrors>mirrors</a>: <a href=dart.mirrors.html#MirrorSystem>MirrorSystem</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#Mirror.>Mirror</a>()<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A Mirror reflects some Dart language entity. </p>
<p>Every Mirror originates from some MirrorSystem.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=Mirror.mirrors></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#MirrorSystem>MirrorSystem</a> mirrors</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=mirrors></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#MirrorSystem>MirrorSystem</a> get mirrors</b>
	<div class=indent>
		<p>The MirrorSystem that contains this mirror.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Mirror.></a><i class=icon-plus-sign></i> Mirror()</b>
	<div class=indent></div>
	<a id=MirrorException></a><hr>
	<h4>
		<i class=icon-leaf></i> Class MirrorException implements <a href=dart.core.html#Exception>Exception</a></h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#MirrorException.>MirrorException</a>(<a href=dart.core.html#String>String</a> _message)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#MirrorException.toString>toString</a>(): <a href=dart.core.html#String>String</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>A MirrorException is used to indicate errors within the mirrors framework.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=MirrorException.></a><i class=icon-plus-sign></i> MirrorException(<a href=dart.core.html#String>String</a> _message)</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=MirrorException.toString></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.toString'><i title='Overrides Object.toString()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#String>String</a> toString()</b>
	<div class=indent>
		<p>Returns a string representation of this object.</p>
	</div>
	<a id=MirrorSystem></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class MirrorSystem</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirrorSystem.dynamicType>dynamicType</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirrorSystem.isolate>isolate</a>: <a href=dart.mirrors.html#IsolateMirror>IsolateMirror</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirrorSystem.libraries>libraries</a>: <a href=dart.core.html#Map>Map</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirrorSystem.voidType>voidType</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#dynamicType>dynamicType</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isolate>isolate</a>: <a href=dart.mirrors.html#IsolateMirror>IsolateMirror</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#libraries>libraries</a>: <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Uri>Uri</a>, <a href=dart.mirrors.html#LibraryMirror>LibraryMirror</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#voidType>voidType</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#MirrorSystem.>MirrorSystem</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#MirrorSystem.findLibrary>findLibrary</a>(<a href=dart.core.html#Symbol>Symbol</a> libraryName): <a href=dart.core.html#Iterable>Iterable</a>&lt;<a href=dart.mirrors.html#LibraryMirror>LibraryMirror</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#MirrorSystem.getName>getName</a>(<a href=dart.core.html#Symbol>Symbol</a> symbol): <a href=dart.core.html#String>String</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>A MirrorSystem is the main interface used to reflect on a set of associated libraries. </p>
<p>At runtime each running isolate has a distinct MirrorSystem. </p>
<p>It is also possible to have a MirrorSystem which represents a set of libraries which are not running -- perhaps at compile-time.  In this case, all available reflective functionality would be supported, but runtime functionality (such as invoking a function or inspecting the contents of a variable) would fail dynamically.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=MirrorSystem.dynamicType></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> dynamicType</b>
	<div class=indent></div>
	<b><a id=MirrorSystem.isolate></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#IsolateMirror>IsolateMirror</a> isolate</b>
	<div class=indent></div>
	<b><a id=MirrorSystem.libraries></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Map>Map</a> libraries</b>
	<div class=indent></div>
	<b><a id=MirrorSystem.voidType></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> voidType</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=dynamicType></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> get dynamicType</b>
	<div class=indent>
		<p>A mirror on the <code>dynamic</code> type.</p>
	</div>
	<b><a id=isolate></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#IsolateMirror>IsolateMirror</a> get isolate</b>
	<div class=indent>
		<p>A mirror on the isolate associated with this MirrorSystem. This may be null if this mirror system is not running.</p>
	</div>
	<b><a id=libraries></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Uri>Uri</a>, <a href=dart.mirrors.html#LibraryMirror>LibraryMirror</a>&gt; get libraries</b>
	<div class=indent>
		<p>An immutable map from from library names to mirrors for all libraries known to this mirror system.</p>
	</div>
	<b><a id=voidType></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> get voidType</b>
	<div class=indent>
		<p>A mirror on the <code>void</code> type.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=MirrorSystem.></a><i class=icon-plus-sign></i> MirrorSystem()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=MirrorSystem.findLibrary></a><i class=icon-ok-sign></i> <a href=dart.core.html#Iterable>Iterable</a>&lt;<a href=dart.mirrors.html#LibraryMirror>LibraryMirror</a>&gt; findLibrary(<a href=dart.core.html#Symbol>Symbol</a> libraryName)</b>
	<div class=indent>
		<p>Returns an iterable of all libraries in the mirror system whose library name is libraryName.</p>
	</div>
	<b><a id=MirrorSystem.getName></a><i class=icon-ok-sign></i> static <a href=dart.core.html#String>String</a> getName(<a href=dart.core.html#Symbol>Symbol</a> symbol)</b>
	<div class=indent>
		<p>Returns the name of symbol. </p>
<p>The following text is non-normative: </p>
<p>Using this method may result in larger output.  If possible, use MirrorsUsed to specify which symbols must be retained in clear text.</p>
	</div>
	<a id=MirroredCompilationError></a><hr>
	<h4>
		<i class=icon-leaf></i> Class MirroredCompilationError extends <a href=dart.mirrors.html#MirroredError>MirroredError</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirroredCompilationError.message>message</a>: <a href=dart.core.html#String>String</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#MirroredCompilationError.>MirroredCompilationError</a>(<a href=dart.core.html#String>String</a> message)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#MirroredCompilationError.toString>toString</a>(): <a href=dart.core.html#String>String</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>When a compile-time error occurs during the mirrored execution of code, a MirroredCompilationError is thrown. </p>
<p>This exception includes the compile-time error message that would have been displayed to the user, if the function had not been invoked via mirror.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=MirroredCompilationError.message></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> message</b>
	<div class=indent></div>
	<h4>Constructors</h4>
	<b><a id=MirroredCompilationError.></a><i class=icon-plus-sign></i> MirroredCompilationError(<a href=dart.core.html#String>String</a> message)</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=MirroredCompilationError.toString></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.toString'><i title='Overrides Object.toString()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#String>String</a> toString()</b>
	<div class=indent>
		<p>Returns a string representation of this object.</p>
	</div>
	<a id=MirroredError></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class MirroredError implements <a href=dart.core.html#Exception>Exception</a></h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#MirroredError.>MirroredError</a>()<br>
		</dd>
	</dl>
	<div class=indent>
		<p>When an error occurs during the mirrored execution of code, a MirroredError is thrown. </p>
<p>In general, there are three main classes of failure that can happen during mirrored execution of code in some isolate: </p>
<p>- An exception is thrown but not caught.  This is caught by the mirrors framework and a MirroredUncaughtExceptionError is created and thrown. </p>
<p>- A compile-time error occurs, such as a syntax error.  This is suppressed by the mirrors framework and a MirroredCompilationError is created and thrown. </p>
<p>- A truly fatal error occurs, causing the isolate to be exited.  If the reflector and reflectee share the same isolate, then they will both suffer.  If the reflector and reflectee are in distinct isolates, then we hope to provide some information about the isolate death, but this has yet to be implemented. </p>
<p>TODO(turnidge): Specify the behavior for remote fatal errors.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=MirroredError.></a><i class=icon-plus-sign></i> MirroredError()</b>
	<div class=indent></div>
	<a id=MirroredUncaughtExceptionError></a><hr>
	<h4>
		<i class=icon-leaf></i> Class MirroredUncaughtExceptionError extends <a href=dart.mirrors.html#MirroredError>MirroredError</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirroredUncaughtExceptionError.exception_mirror>exception_mirror</a>: <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirroredUncaughtExceptionError.exception_string>exception_string</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirroredUncaughtExceptionError.stacktrace>stacktrace</a>: <a href=dart.core.html#Object>Object</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#MirroredUncaughtExceptionError.>MirroredUncaughtExceptionError</a>(<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> exception_mirror, <a href=dart.core.html#String>String</a> exception_string, <a href=dart.core.html#Object>Object</a> stacktrace)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#MirroredUncaughtExceptionError.toString>toString</a>(): <a href=dart.core.html#String>String</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>When an uncaught exception occurs during the mirrored execution of code, a MirroredUncaughtExceptionError is thrown. </p>
<p>This exception contains a mirror on the original exception object. It also contains an object which can be used to recover the stacktrace.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=MirroredUncaughtExceptionError.exception_mirror></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> exception_mirror</b>
	<div class=indent>
		<p>A mirror on the exception object.</p>
	</div>
	<b><a id=MirroredUncaughtExceptionError.exception_string></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> exception_string</b>
	<div class=indent>
		<p>The result of toString() for the exception object.</p>
	</div>
	<b><a id=MirroredUncaughtExceptionError.stacktrace></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Object>Object</a> stacktrace</b>
	<div class=indent>
		<p>A stacktrace object for the uncaught exception.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=MirroredUncaughtExceptionError.></a><i class=icon-plus-sign></i> MirroredUncaughtExceptionError(<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> exception_mirror, <a href=dart.core.html#String>String</a> exception_string, <a href=dart.core.html#Object>Object</a> stacktrace)</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=MirroredUncaughtExceptionError.toString></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.toString'><i title='Overrides Object.toString()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#String>String</a> toString()</b>
	<div class=indent>
		<p>Returns a string representation of this object.</p>
	</div>
	<a id=MirrorsUsed></a><hr>
	<h4>
		<i class=icon-leaf></i> Class MirrorsUsed</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirrorsUsed.metaTargets>metaTargets</a>: dynamic<br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirrorsUsed.override>override</a>: dynamic<br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirrorsUsed.symbols>symbols</a>: dynamic<br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#MirrorsUsed.targets>targets</a>: dynamic<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#MirrorsUsed.>MirrorsUsed</a>(dynamic symbols, dynamic targets, dynamic metaTargets, dynamic override)<br>
		</dd>
	</dl>
	<div class=indent>
		<p>EXPERIMENTAL API: Description of how "dart:mirrors" is used. </p>
<p>When used as metadata on an import of "dart:mirrors" in library <i>L</i>, this class describes how "dart:mirrors" is used by library <i>L</i> unless overridden. See <a href=dart.mirrors.html#override>override</a>. </p>
<p>The following text is non-normative: </p>
<p>In some scenarios, for example, when minifying Dart code, or when generating JavaScript code from a Dart program, the size and performance of the output can suffer from use of reflection.  In those cases, telling the compiler what is used, can have a significant impact. </p>
<p>Example usage: </p>
<p><pre>@MirrorsUsed(symbols: 'foo', override: '*')
import 'dart:mirrors';

class Foo {
  noSuchMethod(Invocation invocation) {
    print(Mirrors.getName(invocation.memberName));
  }
}

main() {
  new Foo().foo(); // Prints "foo".
  new Foo().bar(); // Might print an arbitrary (mangled) name, "bar".
}
</pre></p>
	</div>
	<h4>Fields</h4>
	<b><a id=MirrorsUsed.metaTargets></a><i class=icon-minus-sign></i> final dynamic metaTargets</b>
	<div class=indent>
		<p>A list of classes that when used as metadata indicates a reflective target. </p>
<p>See targets.</p>
	</div>
	<b><a id=MirrorsUsed.override></a><i class=icon-minus-sign></i> final dynamic override</b>
	<div class=indent>
		<p>A list of library names or "*". </p>
<p>When used as metadata on an import of "dart:mirrors", this metadata does not apply to the library in which the annotation is used, but instead applies to the other libraries (all libraries if "*" is used).</p>
	</div>
	<b><a id=MirrorsUsed.symbols></a><i class=icon-minus-sign></i> final dynamic symbols</b>
	<div class=indent>
		<p>The list of strings passed to new Symbol, and symbols that might be passed to MirrorSystem.getName. </p>
<p>Combined with the names of targets, metaTargets and their members, this forms the complete list of strings passed to new Symbol, and symbols that might be passed to MirrorSystem.getName by the library to which this metadata applies. </p>
<p>The following text is non-normative: </p>
<p>Specifying this option turns off the following warnings emitted by dart2js: </p>
<p><ul><li>Using "MirrorSystem.getName" may result in larger output.</li><li>Using "new #{name}" may result in larger output.</li></ul></p>
<p>Use symbols = "*" to turn off the warnings mentioned above. </p>
<p>For example, if using noSuchMethod to interact with a database, extract all the possible column names and include them in this list.  Similarly, if using noSuchMethod to interact with another language (JavaScript, for example) extract all the identifiers from API used and include them in this list.</p>
	</div>
	<b><a id=MirrorsUsed.targets></a><i class=icon-minus-sign></i> final dynamic targets</b>
	<div class=indent>
		<p>A list of reflective targets. </p>
<p>Combined with metaTargets, this provides the complete list of reflective targets used by the library to which this metadata applies. </p>
<p>The following text is non-normative: </p>
<p>For now, there is no formal description of what a reflective target is. Informally, it is a list of things that are expected to have fully functional mirrors.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=MirrorsUsed.></a><i class=icon-plus-sign></i> MirrorsUsed(dynamic symbols, dynamic targets, dynamic metaTargets, dynamic override)</b>
	<div class=indent></div>
	<a id=ObjectMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class ObjectMirror implements <a href=dart.mirrors.html#Mirror>Mirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#ObjectMirror.>ObjectMirror</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ObjectMirror.getField>getField</a>(<a href=dart.core.html#Symbol>Symbol</a> fieldName): <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ObjectMirror.getFieldAsync>getFieldAsync</a>(<a href=dart.core.html#Symbol>Symbol</a> fieldName): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ObjectMirror.invoke>invoke</a>(<a href=dart.core.html#Symbol>Symbol</a> memberName, <a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments): <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ObjectMirror.invokeAsync>invokeAsync</a>(<a href=dart.core.html#Symbol>Symbol</a> memberName, <a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ObjectMirror.setField>setField</a>(<a href=dart.core.html#Symbol>Symbol</a> fieldName, <a href=dart.core.html#Object>Object</a> value): <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#ObjectMirror.setFieldAsync>setFieldAsync</a>(<a href=dart.core.html#Symbol>Symbol</a> fieldName, <a href=dart.core.html#Object>Object</a> value): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>An ObjectMirror is a common superinterface of InstanceMirror, ClassMirror, and LibraryMirror that represents their shared functionality. </p>
<p>For the purposes of the mirrors library, these types are all object-like, in that they support method invocation and field access.  Real Dart objects are represented by the InstanceMirror type. </p>
<p>See InstanceMirror, ClassMirror, and LibraryMirror.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=ObjectMirror.></a><i class=icon-plus-sign></i> ObjectMirror()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=ObjectMirror.getField></a><i class=icon-ok-sign></i> <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> getField(<a href=dart.core.html#Symbol>Symbol</a> fieldName)</b>
	<div class=indent>
		<p>Invokes a getter and returns a mirror on the result. The getter can be the implicit getter for a field or a user-defined getter method. </p>
<p>Let <i>o</i> be the object reflected by this mirror, let <i>f</i> be the simple name of the getter denoted by fieldName, Then this method will perform the getter invocation <i>o.f</i> in a scope that has access to the private members of <i>o</i> (if <i>o</i> is a class or library) or the private members of the class of <i>o</i> (otherwise). If the invocation returns a result <i>r</i>, this method returns the result of calling reflect(<i>r</i>). If the invocation causes a compilation error this method throws a MirroredCompilationError. If the invocation throws an exception <i>e</i> (that it does not catch) this method throws <i>e</i>.</p>
	</div>
	<b><a id=ObjectMirror.getFieldAsync></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt; getFieldAsync(<a href=dart.core.html#Symbol>Symbol</a> fieldName)</b>
	<div class=indent>
		<p>Invokes a getter and returns a mirror on the result. The getter can be the implicit getter for a field or a user-defined getter method. </p>
<p>Let <i>o</i> be the object reflected by this mirror, let <i>f</i> be the simple name of the getter denoted by fieldName, Then this method will perform the getter invocation <i>o.f</i> in a scope that has access to the private members of <i>o</i> (if <i>o</i> is a class or library) or the private members of the class of <i>o</i>(otherwise). The method returns a future <i>k</i>. If the invocation returns a result <i>r</i>, <i>k</i> will be completed with the result of calling reflect(<i>r</i>). If the invocation throws an exception <i>e</i> (that it does not catch) then <i>k</i> is completed with a MirrorError wrapping <i>e</i>.</p>
	</div>
	<b><a id=ObjectMirror.invoke></a><i class=icon-ok-sign></i> <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> invoke(<a href=dart.core.html#Symbol>Symbol</a> memberName, <a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments)</b>
	<div class=indent>
		<p>Invokes the named function and returns a mirror on the result. </p>
<p>Let <i>o</i> be the object reflected by this mirror, let <i>f</i> be the simple name of the member denoted by memberName, let <i>a1, ..., an</i> be the elements of positionalArguments let <i>k1, ..., km</i> be the identifiers denoted by the elements of namedArguments.keys and let <i>v1, ..., vm</i> be the elements of namedArguments.values. Then this method will perform the method invocation <i>o.f(a1, ..., an, k1: v1, ..., km: vm)</i> in a scope that has access to the private members of <i>o</i> (if <i>o</i> is a class or library) or the private members of the class of <i>o</i> (otherwise). If the invocation returns a result <i>r</i>, this method returns the result of calling reflect(<i>r</i>). If the invocation causes a compilation error this method throws a MirroredCompilationError. If the invocation throws an exception <i>e</i> (that it does not catch) this method throws <i>e</i>.</p>
	</div>
	<b><a id=ObjectMirror.invokeAsync></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt; invokeAsync(<a href=dart.core.html#Symbol>Symbol</a> memberName, <a href=dart.core.html#List>List</a>&lt;dynamic&gt; positionalArguments, <a href=dart.core.html#Map>Map</a>&lt;<a href=dart.core.html#Symbol>Symbol</a>, dynamic&gt; namedArguments)</b>
	<div class=indent>
		<p>Invokes the named function and returns a mirror on the result. The arguments must be instances of InstanceMirror, or of a type that is serializable across isolates (currently num, String, or bool). </p>
<p>Let <i>o</i> be the object reflected by this mirror, let <i>f</i> be the simple name of the member denoted by memberName, let <i>a1, ..., an</i> be the elements of positionalArguments let <i>k1, ..., km</i> be the identifiers denoted by the elements of namedArguments.keys and let <i>v1, ..., vm</i> be the elements of namedArguments.values. For each <i>ai</i>, if <i>ai</i> is an instance of InstanceMirror, let <i>pi</i> be the object reflected by <i>ai</i>; otherwise let <i>pi = ai,  i in 1 ...n</i>. Likewise, for each <i>vj</i>, if <i>vj</i> is an instance of InstanceMirror, let <i>qj</i> be the object reflected by <i>vj</i>; otherwise let <i>qj = vj,  j in 1 ...m</i>. If any of the <i>pi, qj</i> is not an instance of InstanceMirror and is not serializable across isolates, an exception is thrown. Then this method will perform the method invocation <i>o.f(p1, ..., pn, k1: q1, ..., km: qm)</i> in a scope that has access to the private members of <i>o</i> (if <i>o</i> is a class or library) or the private members of the class of <i>o</i>(otherwise). The method returns a future <i>k</i>. If the invocation returns a result <i>r</i>, <i>k</i> will be completed with the result of calling reflect(<i>r</i>). If the invocation throws an exception <i>e</i> (that it does not catch) then <i>k</i> is completed with a MirrorError wrapping <i>e</i>.</p>
	</div>
	<b><a id=ObjectMirror.setField></a><i class=icon-ok-sign></i> <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> setField(<a href=dart.core.html#Symbol>Symbol</a> fieldName, <a href=dart.core.html#Object>Object</a> value)</b>
	<div class=indent>
		<p>Invokes a setter and returns a mirror on the result. The setter may be either the implicit setter for a non-final field or a user-defined setter method. </p>
<p>Let <i>o</i> be the object reflected by this mirror, let <i>f</i> be the simple name of the getter denoted by fieldName, and let <i>a</i> be the object bound to value. Then this method will perform the setter invocation <i>o.f = a</i> in a scope that has access to the private members of <i>o</i> (if <i>o</i> is a class or library) or the private members of the class of <i>o</i> (otherwise). If the invocation returns a result <i>r</i>, this method returns the result of calling reflect(value). If the invocation causes a compilation error this method throws a MirroredCompilationError. If the invocation throws an exception <i>e</i> (that it does not catch) this method throws <i>e</i>.</p>
	</div>
	<b><a id=ObjectMirror.setFieldAsync></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a>&gt; setFieldAsync(<a href=dart.core.html#Symbol>Symbol</a> fieldName, <a href=dart.core.html#Object>Object</a> value)</b>
	<div class=indent>
		<p>Invokes a setter and returns a mirror on the result. The setter may be either the implicit setter for a non-final field or a user-defined setter method. The second argument must be an instance of InstanceMirror, or of a type that is serializable across isolates (currently num, String, or bool). </p>
<p>Let <i>o</i> be the object reflected by this mirror, let <i>f</i> be the simple name of the getter denoted by fieldName, and let a be the object bound to value. If <i>a</i> is an instance of InstanceMirror  let <i>p</i> be the object reflected by <i>a</i>, otherwise let <i>p =a</i>. If <i>p</i> is not an instance of InstanceMirror, <i>p</i> must be serializable across isolates or an exception is thrown. Then this method will perform the setter invocation <i>o.f = a</i> in a scope that has access to the private members of <i>o</i> (if <i>o</i> is a class or library) or the private members of the class of <i>o</i>(otherwise). The method returns a future <i>k</i>. If the invocation returns a result <i>r</i>, <i>k</i> will be completed with the result of calling reflect(<i>r</i>). If the invocation throws an exception <i>e</i> (that it does not catch) then <i>k</i> is completed with a [MirrorError} wrapping <i>e</i>.</p>
	</div>
	<a id=ParameterMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class ParameterMirror implements <a href=dart.mirrors.html#VariableMirror>VariableMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ParameterMirror.defaultValue>defaultValue</a>: <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ParameterMirror.hasDefaultValue>hasDefaultValue</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ParameterMirror.isNamed>isNamed</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ParameterMirror.isOptional>isOptional</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#ParameterMirror.type>type</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#defaultValue>defaultValue</a>: <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#hasDefaultValue>hasDefaultValue</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isNamed>isNamed</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isOptional>isOptional</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#type>type</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#ParameterMirror.>ParameterMirror</a>()<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A ParameterMirror reflects a Dart formal parameter declaration.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=ParameterMirror.defaultValue></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> defaultValue</b>
	<div class=indent></div>
	<b><a id=ParameterMirror.hasDefaultValue></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> hasDefaultValue</b>
	<div class=indent></div>
	<b><a id=ParameterMirror.isNamed></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isNamed</b>
	<div class=indent></div>
	<b><a id=ParameterMirror.isOptional></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isOptional</b>
	<div class=indent></div>
	<b><a id=ParameterMirror.type></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> type</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=defaultValue></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#InstanceMirror>InstanceMirror</a> get defaultValue</b>
	<div class=indent>
		<p>If this is a required parameter, returns <code>null</code>. Otherwise returns a mirror on the default value for this parameter. If no default is declared for an optional parameter, the default is <code>null</code> and a mirror on <code>null</code> is returned.</p>
	</div>
	<b><a id=hasDefaultValue></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get hasDefaultValue</b>
	<div class=indent>
		<p>Returns <code>true</code> if the reflectee has explicitly declared a default value. Otherwise returns <code>false</code>.</p>
	</div>
	<b><a id=isNamed></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isNamed</b>
	<div class=indent>
		<p>Returns <code>true</code> if the reflectee is a named parameter. Otherwise returns <code>false</code>.</p>
	</div>
	<b><a id=isOptional></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isOptional</b>
	<div class=indent>
		<p>Returns <code>true</code> if the reflectee is an optional parameter. Otherwise returns <code>false</code>.</p>
	</div>
	<b><a id=type></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> get type</b>
	<div class=indent>
		<p>A mirror on the type of this parameter.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=ParameterMirror.></a><i class=icon-plus-sign></i> ParameterMirror()</b>
	<div class=indent></div>
	<a id=SourceLocation></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class SourceLocation</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#SourceLocation.>SourceLocation</a>()<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A SourceLocation describes the span of an entity in Dart source code.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=SourceLocation.></a><i class=icon-plus-sign></i> SourceLocation()</b>
	<div class=indent></div>
	<a id=TypeMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class TypeMirror implements <a href=dart.mirrors.html#DeclarationMirror>DeclarationMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#TypeMirror.>TypeMirror</a>()<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A TypeMirror reflects a Dart language class, typedef, or type variable.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=TypeMirror.></a><i class=icon-plus-sign></i> TypeMirror()</b>
	<div class=indent></div>
	<a id=TypeVariableMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class TypeVariableMirror extends <a href=dart.mirrors.html#TypeMirror>TypeMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#TypeVariableMirror.upperBound>upperBound</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#upperBound>upperBound</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#TypeVariableMirror.>TypeVariableMirror</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#TypeVariableMirror.==>==</a>(dynamic other): <a href=dart.core.html#bool>bool</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>A TypeVariableMirror represents a type parameter of a generic type.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=TypeVariableMirror.upperBound></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> upperBound</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=upperBound></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> get upperBound</b>
	<div class=indent>
		<p>A mirror on the type that is the upper bound of this type variable.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=TypeVariableMirror.></a><i class=icon-plus-sign></i> TypeVariableMirror()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=TypeVariableMirror.==></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.=='><i title='Overrides Object.==()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#bool>bool</a> ==(dynamic other)</b>
	<div class=indent>
		<p>Returns <code>true</code> if this mirror is equal to other. Otherwise returns <code>false</code>. </p>
<p>The equality holds if and only if (1) other is a mirror of the same kind and (2)  <code>simpleName == other.simpleName</code> and <code>owner == other.owner</code>.</p>
	</div>
	<a id=TypedefMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class TypedefMirror implements <a href=dart.mirrors.html#ClassMirror>ClassMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#TypedefMirror.value>value</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#value>value</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#TypedefMirror.>TypedefMirror</a>()<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A TypedefMirror represents a typedef in a Dart language program.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=TypedefMirror.value></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> value</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=value></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> get value</b>
	<div class=indent>
		<p>The defining type for this typedef. </p>
<p>For instance <code>void f(int)</code> is the value for <code>typedef void f(int)</code>.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=TypedefMirror.></a><i class=icon-plus-sign></i> TypedefMirror()</b>
	<div class=indent></div>
	<a id=VariableMirror></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class VariableMirror implements <a href=dart.mirrors.html#DeclarationMirror>DeclarationMirror</a></h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#VariableMirror.isFinal>isFinal</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#VariableMirror.isStatic>isStatic</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.mirrors.html#VariableMirror.type>type</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isFinal>isFinal</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#isStatic>isStatic</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#type>type</a>: <a href=dart.mirrors.html#TypeMirror>TypeMirror</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.mirrors.html#VariableMirror.>VariableMirror</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.mirrors.html#VariableMirror.==>==</a>(dynamic other): <a href=dart.core.html#bool>bool</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>A VariableMirror reflects a Dart language variable declaration.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=VariableMirror.isFinal></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isFinal</b>
	<div class=indent></div>
	<b><a id=VariableMirror.isStatic></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isStatic</b>
	<div class=indent></div>
	<b><a id=VariableMirror.type></a><i class=icon-minus-sign></i> final <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> type</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=isFinal></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isFinal</b>
	<div class=indent>
		<p>Returns <code>true</code> if the reflectee is a final variable. Otherwise returns <code>false</code>.</p>
	</div>
	<b><a id=isStatic></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isStatic</b>
	<div class=indent>
		<p>Returns <code>true</code> if the reflectee is a static variable. Otherwise returns <code>false</code>. </p>
<p>For the purposes of the mirror library, top-level variables are implicitly declared static.</p>
	</div>
	<b><a id=type></a><i class=icon-circle-arrow-right></i> <a href=dart.mirrors.html#TypeMirror>TypeMirror</a> get type</b>
	<div class=indent>
		<p>Returns a mirror on the type of the reflectee.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=VariableMirror.></a><i class=icon-plus-sign></i> VariableMirror()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=VariableMirror.==></a><i class=icon-ok-sign></i> <a href='dart.core.html#Object.=='><i title='Overrides Object.==()' class='icon-circle-arrow-up'></i></a> <a href=dart.core.html#bool>bool</a> ==(dynamic other)</b>
	<div class=indent>
		<p>Returns true if this mirror is equal to other. </p>
<p>The equality holds if and only if (1) other is a mirror of the same kind and (2)  <code>simpleName == other.simpleName</code> and <code>owner == other.owner</code>.</p>
	</div>
	<hr>
</div>
</div>
</div>
<footer>
</footer>
</body>
</html>
